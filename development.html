<!DOCTYPE html>
<html data-protected="all">
    <head>
        <title>Codestrates package repository</title>
        <meta charset="UTF-8">
    </head> 
    <body> 
        <div class="packages">            
            <div class="package" id="js-eval-engine">
                <script id="descriptor-script" type="descriptor">
{
    "description": "Javascript Evaluator Engine",
    "dependencies": [
        "#EventSystem"
    ],
    "assets": [],
    "license": "Apache 2.0", 
    "version": "1"
}

</script>

                <script id="jsEvalEngine-script" type="disabled">
/**
 *  JsEvalEngine
 *  Evaluate js while keeping track of it
 * 
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *    
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/
    
function codeStratesEvalInContext(code, context) {
    with(context) {
        eval(code);
    }
}

window.JsEvalEngine = class JsEvalEngine {
    static async execute(code, options, fragment = null) {

        options = Object.assign({}, JsEvalEngine.defaultOptions(fragment), options);

        let resolver = null;
        let rejector = null;

        let asyncPromise = new Promise((resolve, reject)=>{
            resolver = resolve;
            rejector = reject;
        });

        let clonedConsole = Object.assign({}, console, options.customConsole);

        let context = {
            exports: {},
            asyncResolve: resolver,
            asyncReject: rejector,
            console: clonedConsole,
            fragmentSelfReference: fragment,
            error: (e)=>{
                let parsedStack = JsEvalEngine.parseErrorStack(e.name, e.stack, e);
                EventSystem.triggerEvent("Codestrates.Fragment.Error", {
                    messages: [parsedStack],
                    fragment: fragment
                });
                let compactStack = StackWalker.compactify(parsedStack.stack);
                let lineNumber = compactStack[0].lineNumber;
                JsEvalEngine.doLog(console.error, fragment, lineNumber, parsedStack.extraReason, compactStack);
            }
        };

        if(options.context != null) {
            context = Object.assign({}, context, options.context);
        }

        let asyncCode = code;

        if(options.async) {
            asyncCode = JsEvalEngine.wrapInAsync(code, fragment != null ? "CS_ASYNC_" + fragment.uuid.replace("-", "_") : null);
        }

        try {
            codeStratesEvalInContext.call(null, asyncCode, context);
            if(!options.async) {
                context.asyncResolve();
            }
        } catch(e) {
            context.error(e);
            throw e;
        }

        await asyncPromise.catch((e)=>{context.error(e); throw e});

        return context[options.exportsName];
    }

    static wrapInAsync(code, methodName) {
        if(methodName == null) {
            methodName = "anonymousAsyncEval";
        }

        //Make code async
        return `(async function ${methodName}() { ${code} \n })().then(()=>{asyncResolve();}).catch((e)=>{asyncReject(e);});`;
    }

    static parseErrorStack(name, stack, error) {
        let parsedStackTrace = [];
        let extraReason = null;

        if(stack == null) {
            console.warn("parseErrorStack: empty stack!");
            return new StackWalker.StackTrace(
                error,
                [],
                null
            );
        }

        if(window.chrome) {
            let stackSplit = stack.split("\n");

            if(!stackSplit[0].trim().startsWith("at")) {
                extraReason = stackSplit[0];
            }

            stackSplit.filter((line)=>{
                return line.trim().startsWith("at");
            }).forEach((line)=>{
                let trimmedLine = line.trim();

                let functionName = trimmedLine.substring(3, trimmedLine.indexOf("(")).trim();

                let lineNumberAndPosition = trimmedLine.substring(trimmedLine.indexOf("),")+2).trim().split(":");

                let lineNumber = parseInt(lineNumberAndPosition[1]);

                if(Number.isNaN(lineNumber)) {
                    lineNumber = null;
                }

                parsedStackTrace.push({
                    method: functionName,
                    lineNumber: lineNumber,
                    debug: trimmedLine
                });
            });
        } else {
            console.log("Unsupported browser for parsing stack trace");
            parsedStackTrace = stack;
        }

        return new StackWalker.StackTrace(
            name,
            parsedStackTrace,
            extraReason
        );
    }

    static defaultOptions(fragment = null) {
        return {
            context: null,
            exportsName: "exports",
            async: true,
            customConsole: {
                log: (...messages)=> {
                    JsEvalEngine.doLog(console.log, fragment, null, ...messages);
                    if(typeof EventSystem !== "undefined") {
                        EventSystem.triggerEvent("Codestrates.Fragment.Log", {
                            messages: messages,
                            fragment: fragment
                        });
                    }
                },
                warn: (...messages)=>{
                    JsEvalEngine.doLog(console.warn, fragment, null, ...messages);
                    if(typeof EventSystem !== "undefined") {
                        EventSystem.triggerEvent("Codestrates.Fragment.Warn", {
                            messages: messages,
                            fragment: fragment
                        });
                    }
                },
                error: (...messages)=>{
                    JsEvalEngine.doLog(console.error, fragment, null, ...messages);
                    if(typeof EventSystem !== "undefined") {
                        EventSystem.triggerEvent("Codestrates.Fragment.Error", {
                            messages: messages,
                            fragment: fragment
                        });
                    }
                }
            }
        };
    }

    static doLog(logger, fragment, lineNumber, ...messages) {
        if(fragment != null) {
            let name = fragment.html[0].getAttribute("name");
            let id = fragment.html[0].getAttribute("id");

            logger("Fragment ["+(name!=null&&name.trim()!==""?name:fragment.type)+(id!=null&&id.trim()!==""?"#"+id:"")+(lineNumber!=null?":"+lineNumber:"")+"]", ...messages);
        } else {
            logger(...messages);
        }
    }
};

window.addEventListener("unhandledrejection", (evt)=>{
    if(evt.reason != null) {
        let parsedStack = JsEvalEngine.parseErrorStack(evt.reason.name, evt.reason.stack);
        EventSystem.triggerEvent("Codestrates.Fragment.Error", {
            messages: ["Uncaught rejection in promise: ", parsedStack]
        });
    } else {
        console.warn("Did not include a reason property:", evt);
    }
});

window.addEventListener("error", (evt)=>{
    if(evt.error != null) {
        let parsedStack = JsEvalEngine.parseErrorStack(evt.error.message, evt.error.stack);
        EventSystem.triggerEvent("Codestrates.Fragment.Error", {
            messages: ["Uncaught exception: ", parsedStack]
        });
    } else {
        console.warn("Did not include an error property:", evt);
    }
});

//Setup infinite stack depth
Error.stackTraceLimit = Infinity;

</script>

            </div>
            
            <div class="package" id="fragment_core">
                <script id="descriptor-script" type="descriptor">
{
    "description": "The base fragment core required by all fragments",
    "dependencies": [
        "/wpm_js_libs/?raw #cQuery",
        "/wpm_js_libs/?raw #Observer",
        "/wpm_js_libs/?raw #fastdiff",
        "/wpm_js_libs/?raw #diffHTML",
        "/wpm_common/?raw #UUIDGenerator"
    ],
    "license": "Apache 2.0",
    "assets": [],
    "version": "1"
}

</script>

                <style id="base-style">
code-fragment {
    display: none;
}
</style>

                <script id="fragment_core-script" type="disabled">
/**
 *  Fragment
 *  The base class for all code fragments in Codestrates
 * 
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *    
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

/* global cQuery, webstrate, HTMLElement, NodeList, UUIDGenerator, Observer, WPMv2, Text, DIFF_INSERT, DIFF_DELETE, wpm */

const dmp = new diff_match_patch();

/**
 * @namespace Fragments
 */

/**
 * Codestrate Fragment representing a <code-fragment></code-fragment> tag in codestrates.
 * @abstract
 * @hideconstructor
 * @memberof Fragments
 */
class Fragment {
    /**
     * Create a new fragment using the given cQuery object as its base.
     * @param {cQuery} html - The cQuery object to use as base.
     */
    constructor(html) {
        let self = this;

        this.html = html;

        this.html.data("Fragment", this);

        this.textInsertedCallbacks = [];
        this.textDeletedCallbacks = [];
        this.fragmentChangedCallbacks = [];
        this.fragmentUnloadedCallbacks = [];
        this.fragmentClassChangedCallbacks = [];
        this.fragmentAutoChangedCallbacks = [];

        this.uuid = UUIDGenerator.generateUUID("fragment-");

        //Setup autodom and make it able to wait until it is complete.
        this.setupAutoDomHandling();

        this.html[0].setAttribute("transient-fragment-uuid", this.uuid);

        this.setupObservers();
        this.startObserver();
    }

    /**
     * Get the node that holds the text content of this fragment
     * @protected
     * @ignore
     * @returns {Text}
     */
    getTextContentNode() {
        let textContentNode = this.html[0];

        this.checkTextContentNode(textContentNode);

        return textContentNode;
    }

    /**
     * Checks the given node for its feasibility of being the textContentNode
     * @protected
     * @ignore
     * @param {Text} textContentNode - The text node to check
     */
    checkTextContentNode(textContentNode) {
        if(textContentNode.childNodes.length > 1) {
            console.warn("More than 1 childnode...", textContentNode.childNodes);
        }
    }

    /**
     * Triggers all callback handlers for the given type insert/delete
     * @private
     * @param {number} pos - The position the event happened
     * @param {string} val - The value of the event
     * @param {insert|delete} type - The type of the event
     */
    insertDeleteCallback(pos, val, type) {
        switch (type) {
            case "insert":
            {
                this.textInsertedCallbacks.forEach((callback) => {
                    callback(pos, val);
                });
                
                break;
            }
            case "delete":
            {
                this.textDeletedCallbacks.forEach((callback) => {
                    callback(pos, val);
                });
                
                break;
            }
        }
    }

    /**
     * Handle the given mutations
     * @private
     * @param {Mutation[]} mutations - The mutations to handle
     */
    mutationCallback(mutations) {
        let self = this;
        
        let characterDataTargets = [];

        let sendUpdateCallback = false;

        mutations.forEach((mutation) => {
            if(mutation.type === "attributes") {
                sendUpdateCallback = true;
            }

            if (mutation.type === "attributes" && mutation.attributeName === "auto" && mutation.target === self.html[0]) {
                //If auto attribute changed, trigger onAutoChanged
                self.onAutoChanged(self.auto);
                sendUpdateCallback = false;
            } else if (mutation.type === "attributes" && mutation.attributeName === "class" && mutation.target === self.html[0]) {
                //If auto attribute changed, trigger onAutoChanged
                self.onClassChanged(this.html[0].classList);
                sendUpdateCallback = false;
            } else if(mutation.type === "characterData") {
                if(mutation.target.characterDataAlreadyHandled) {
                    return;
                }

                sendUpdateCallback = true;

                characterDataTargets.push(mutation.target);
                let newValue = mutation.target.nodeValue;
                let oldValue = mutation.oldValue;
                mutation.target.characterDataAlreadyHandled = true;
                
                //If characterData mutation, generate insert/delete ops
                let patches = dmp.patch_make(oldValue, newValue);
                Array.from(patches).forEach((patch)=>{
                    let offset = patch.start1;
                    patch.diffs.forEach((diff) => {
                        let type = diff[0];
                        let value = diff[1];
                        
                        switch(type) {
                            case DIFF_INSERT:
                                self.insertDeleteCallback(offset, value, "insert");
                                offset += value.length;
                                break;
                            case DIFF_DELETE:
                                self.insertDeleteCallback(offset, value, "delete");
                                break;
                            case DIFF_EQUAL:
                                offset += value.length;
                                break;
                        }
                    });
                });
            } else if(mutation.type === "childList") {
                sendUpdateCallback = true;
            }
        });
        
        characterDataTargets.forEach((target)=>{
            target.characterDataAlreadyHandled = false;
        });

        //Only send
        if(this.html[0].parentNode != null && sendUpdateCallback) {
            //Dont do changed callbacks if we are not in the dom?
            this.triggerFragmentChanged(this);
        }
    }

    triggerFragmentChanged(context) {
        this.fragmentChangedCallbacks.slice().forEach((callback) => {
            try {
                callback(context);
            } catch(e) {
                console.group("Error: "+e);
                console.log("Callback:", callback);
                console.log("Context:", context);
                console.groupCollapsed("Trace");
                console.trace();
                console.groupEnd();
                console.groupEnd();
            }
        });
    }

    /**
     * Sets up the mutation observer for this fragment
     * @ignore
     * @protected
     */
    setupObservers() {
        let self = this;

        this.mutationHandler = (mutations) => {
            self.mutationCallback(mutations);
        };

        this.observer = new MutationObserver(this.mutationHandler);
    }

    /**
     * Starts this fragments mutation observer
     * @ignore
     * @protected
     */
    startObserver() {
        if(this.observer == null) {
            return;
        }
        
        this.observer.observe(this.html[0], {
            attributes: true,
            childList: true,
            subtree: true,
            characterData: true,
            characterDataOldValue: true
        });
    }

    /**
     * Stops this fragments mutation observer, handling any mutations that is queued before stopping.
     * @ignore
     * @protected
     */
    stopObserver() {
        if(this.observer == null) {
            return;
        }
        
        let mutations = this.observer.takeRecords();

        if (mutations.length > 0) {
            this.mutationCallback(mutations);
        }

        this.observer.disconnect();
    }

    /**
     * Run the given method without triggering the mutation observer on this fragment, then trigger fragment changed callbacks with the given context
     * @ignore
     * @protected
     * @param {Function} method - Method to call. Important: cannot be async or return a promise, the observer will be restarted as soon as this method returns.
     * @param {Object} context - Context to pass along to the callbacks
     */
    executeObserverless(method, context, skipChangeCheck=false) {
        this.stopObserver();

        let before = null;

        if(!skipChangeCheck) {
            before = this.raw;
        }

        //Run our method, potentially adding mutations
        method();
        
        this.startObserver();

        if(skipChangeCheck || before !== this.raw) {
            this.triggerFragmentChanged(context);
        }
    }

    /**
     * The raw representation of this fragment
     * @type {string}
     */
    get raw() {
        if(this.getTextContentNode().firstChild instanceof Text) {
            return this.getTextContentNode().firstChild.nodeValue;
        } else {
            return this.getTextContentNode().textContent;
        }
    }

    set raw(content) {
        if(this.getTextContentNode().firstChild instanceof Text) {
            this.getTextContentNode().firstChild.nodeValue = content;
        } else {
            this.getTextContentNode().textContent = content;
        }
    }

    /**
     * The auto attribute of this fragment, toggles automatic behaviour on/off
     * @type {boolean}
     */
    get auto() {
        return this.html[0].hasAttribute("auto");
    }

    set auto(auto) {
        if (auto) {
            this.html[0].setAttribute("auto", "");
        } else {
            this.html[0].removeAttribute("auto");
        }
    }

    /**
     * @callback Fragments.Fragment~fragmentChangedCallback
     * @param {Fragment|Object} context - The context that called the callback
     */

    /**
     * Register a callback to be run when this fragments content changes.
     *
     * @example
     * Fragment.one("#myFragment").registerOnFragmentChangedHandler((context)=>{
     *     //Fragment has changed
     * });
     *
     * @param {Fragments.Fragment~fragmentChangedCallback} callback - The callback that is run when fragment content changes
     */
    registerOnFragmentChangedHandler(callback) {
        let self = this;

        this.fragmentChangedCallbacks.push(callback);

        return {
            delete: ()=>{
                self.unRegisterOnFragmentChangedHandler(callback);
            }
        }
    }

    /**
     * Unregister a callback handler
     * @param {Fragments.Fragment~fragmentChangedCallback} callback - The callback to unregister
     */
    unRegisterOnFragmentChangedHandler(callback) {
        this.fragmentChangedCallbacks.splice(this.fragmentChangedCallbacks.indexOf(callback), 1);
    }

    /**
     * @callback Fragments.Fragment~fragmentUnloadedCallback
     * @param {Fragments.Fragment} fragment - The fragment that called the callback
     */

    /**
     * Register a callback to run when this fragment is unloaded
     *
     * @example
     * Fragment.one("#myFragment").registerOnFragmentUnloadedHandler(()=>{
     *     //Fragment is unloaded
     * });
     *
     * @param {Fragments.Fragment~fragmentUnloadedCallback} callback - The callback to run when the fragment is unloaded
     */
    registerOnFragmentUnloadedHandler(callback) {
        let self = this;

        this.fragmentUnloadedCallbacks.push(callback);

        return {
            delete: ()=>{
                self.unRegisterOnFragmentUnloadedHandler(callback);
            }
        }
    }

    /**
     * Unregister a callback handler
     * @param {Fragments.Fragment~fragmentUnloadedCallback} callback - The callback to unregister
     */
    unRegisterOnFragmentUnloadedHandler(callback) {
        this.fragmentUnloadedCallbacks.splice(this.fragmentUnloadedCallbacks.indexOf(callback), 1);
    }

    /**
     * @callback Fragments.Fragment~autoChangedCallback
     * @param {Fragments.Fragment} fragment - The fragment
     * @param {boolean} auto - The new value of auto
     */

    /**
     * Register a callback to run when auto attribute changes on fragment
     *
     * @example
     * Fragment.one("#myFragment").registerOnAutoChangedHandler((fragment, auto)=>{
     *     //Fragment auto attribute changed
     * });
     *
     * @param {Fragments.Fragment~autoChangedCallback} callback - The callback to run when auto changes
     */
    registerOnAutoChangedHandler(callback) {
        let self = this;

        this.fragmentAutoChangedCallbacks.push(callback);

        return {
            delete: ()=>{
                self.unRegisterOnAutoChangedHandler(callback);
            }
        }
    }

    /**
     * Unregister a callback handler
     * @param {Fragments.Fragment~autoChangedCallback} callback - The callback to unregister
     */
    unRegisterOnAutoChangedHandler(callback) {
        this.fragmentAutoChangedCallbacks.splice(this.fragmentAutoChangedCallbacks.indexOf(callback), 1);
    }

    /**
     * @callback Fragments.Fragment~textInsertedCallback
     * @param {number} position - The position where the text was inserted
     * @param {string} value - The value of inserted text
     */

    /**
     * Register a callback to run when text is inserted into this fragment
     *
     * @example
     * Fragment.one("#myFragment").registerOnTextInsertedHandler((position, value)=>{
     *     //Text "value" has been inserted into this fragment at "position"
     * });
     *
     * @param {Fragments.Fragment~textInsertedCallback} callback - The callback to run when text is inserted
     */
    registerOnTextInsertedHandler(callback) {
        let self = this;

        this.textInsertedCallbacks.push(callback);

        return {
            delete: ()=>{
                self.textInsertedCallbacks.splice(self.textInsertedCallbacks.indexOf(callback), 1);
            }
        }
    }

    /**
     * @callback Fragments.Fragment~textDeletedCallback
     * @param {number} position - The position where the text was deleted
     * @param {string} value - The value of deleted text
     */

    /**
     * Register a callback to run when text is deleted from this fragment
     *
     * @example
     * Fragment.one("#myFragment").registerOnTextDeletedHandler((position, value)=>{
     *     //Text "value" has been deleted from this fragment at "position"
     * });
     *
     * @param {Fragments.Fragment~textDeletedCallback} callback - The callback to run when text is deleted
     */
    registerOnTextDeletedHandler(callback) {
        let self = this;

        this.textDeletedCallbacks.push(callback);

        return {
            delete: ()=>{
                self.textDeletedCallbacks.splice(self.textDeletedCallbacks.indexOf(callback), 1);
            }
        }
    }

    /**
     * @callback Fragments.Fragment~fragmentClassChangedCallback
     * @param {string[]} classes - The classes that changed
     */

    /**
     * Register a callback to run when the classes of this fragment changes
     *
     * @example
     * Fragment.one("#myFragment").registerOnClassChangedHandler((classes)=>{
     *     //Some classes changed on this fragment
     * });
     *
     * @param {Fragments.Fragment~fragmentClassChangedCallback} callback - The callback to run when classes change on the fragment
     */
    registerOnClassChangedHandler(callback) {
        let self = this;

        this.fragmentClassChangedCallbacks.push(callback);

        return {
            delete: ()=>{
                self.fragmentClassChangedCallbacks.splice(self.fragmentClassChangedCallbacks.indexOf(callback), 1);
            }
        }
    }

    /**
     * Handles when classes change on the fragment
     * @private
     * @param classes
     */
    onClassChanged(classes) {
        this.fragmentClassChangedCallbacks.slice().forEach((cb)=>{
            cb(classes);
        });
    }

    /**
     * The type of this fragment
     * @type {string}
     * @readonly
     */
    get type() {
        return this.html[0].getAttribute("data-type");
    }

    /**
     * Require this fragment and return the result. What require does depends on what type of fragment it is.
     * @example
     * let result = await Fragment.one("#myFragment").require()
     *
     * @abstract
     * @param {json} [options] - The options to pass to require
     * @returns {*} result of the require action
     */
    async require(options = {}) {
        //Ovewritten in subclass
    }

    /**
     * Tell this fragment to unload itself
     * @example
     * Fragment.one("#myFragment").unload();
     */
    unload() {
        let self = this;
        
        this.fragmentUnloadedCallbacks.slice().forEach((callback)=>{
            callback(self);
        });

        if(this.supportsAutoDom()) {
            this.clearAutoDom();
        }

        this.stopObserver();
        this.html.data("Fragment", null);
        this.html = null;
    }

    /**
     * Called when all fragments are loaded
     * @private
     */
    async onFragmentsLoaded() {
        if (this.auto) {
            await this.insertAutoDom();
        }
    }

    /**
     * @private
     * @returns {boolean} - True/False depending on if this fragments supports automatic behaviour
     */
    supportsAuto() {
        return this.supportsAutoDom();
    }

    /**
     * @private
     * @returns {boolean} True/False depending on if this fragment supports automatic dom insertion
     */
    supportsAutoDom() {
        //Override in subclass
        return false;
    }


    /**
     * Setup handling of automatic dom insertion
     * @private
     * @returns {Promise<void>}
     */
    setupAutoDomHandling() {
        if(!this.supportsAutoDom()) {
            return;
        }

        let self = this;

        this.registerOnFragmentChangedHandler((context) => {
            if (self.auto) {
                self.insertAutoDom();
            }
        });
    }

    /**
     * Called when auto attribute is changed on this fragment
     * @private
     * @param {boolean} auto - The new state of auto
     */
    onAutoChanged(auto) {
        this.fragmentAutoChangedCallbacks.forEach((cb)=>{
            cb(this, auto);
        });

        if(!this.supportsAutoDom()) {
            return;
        }

        if (auto) {
            this.insertAutoDom();
        } else {
            this.clearAutoDom();
        }
    }

    /**
     * Create an instance of the automatic dom
     * @private
     * @returns {Promise<*>}
     */
    async createAutoDom() {
        if(!this.supportsAutoDom()) {
            return;
        }

        try {
            return await this.require();
        } catch(e) {
            return null;
        }
    }

    /**
     * Ask this fragment to insert its automatic dom
     * @ignore
     * @returns {Promise<void>} - Promise that resolves when the automatic dom is inserted into the document
     */
    async insertAutoDom() {
        if(!this.supportsAutoDom() || Fragment.disableAutorun) {
            return;
        }

        let self = this;

        try {
            let autoDomContent = await this.createAutoDom();

            let oldTransient = cQuery("transient.autoDom#" + this.uuid);
            if(oldTransient.length > 0) {
                oldTransient[0].setAttribute("class", "autoDom");

                //Fix missing classes
                this.html[0].classList.forEach((c)=>{
                    oldTransient[0].addClass(c);
                });

                try {
                    diff.innerHTML(oldTransient[0], autoDomContent, { parser: { strict: true } });
                } catch (ex){
                    console.error("Failed to perform autoDOM diffing", ex);
                    diff.release(oldTransient[0]); // Reset state trackers since the patch was not applied
                }

                function cssPath(element, path= []) {
                    if(element.parentNode == null) {
                        // Document fragment is the top node
                        return path.reverse().join(" > ");
                    }

                    const parent = element.parentNode;
                    const childIndex = Array.from(parent.children).indexOf(element) + 1;
                    path.push(element.nodeName.toLowerCase()+":nth-child("+childIndex+")");
                    return cssPath(parent, path);
                }

                // Update innerHTML for each template, as this is not part of the dom, and would not be updated otherwise
                cQuery(autoDomContent).find("template").forEach((template)=>{
                    let path = cssPath(template);
                    oldTransient[0].querySelector(path).innerHTML = autoDomContent.querySelector(path).innerHTML;
                });
            } else {
                let transient = cQuery("<transient></transient>");
                transient[0].setAttribute("id", this.uuid);
                transient.addClass("autoDom");

                this.html[0].classList.forEach((c)=>{
                    transient.addClass(c);
                });

                if (autoDomContent != null && autoDomContent !== "") {
                    transient.append(autoDomContent);
                }                
                this.html[0].parentNode.insertBefore(transient[0], this.html[0].nextSibling);
            }

        } catch(e) {
            console.warn("Unable to insertAutoDom: ", e);
        }
    }

    /**
     * Clear this fragments automatic dom from the document
     * @ignore
     */
    clearAutoDom() {
        if(!this.supportsAutoDom()) {
            return;
        }
        cQuery("transient.autoDom#" + this.uuid).remove();
    }

    /**
     * Returns whether this fragment supports the run flag
     * @private
     * @returns {boolean}
     */
    supportsRun() {
        return false;
    }

    /**
     * Returns a dompath for finding this fragment
     */
    getDomPath() {
        let child = this.html[0];
        let parent = this.html[0].parentNode;

        let domPath = [];

        while(parent.parentNode != null) {
            let children = Array.from(parent.childNodes);

            let childIndex = children.indexOf(child);

            domPath.push({
                parent: parent.tagName,
                childIndex: childIndex
            });

            child = parent;
            parent = parent.parentNode;
        }

        domPath.reverse()

        return domPath;
    }

    static findFromDomPath(domPath) {
        let currentParent = document.querySelector(domPath[0].parent);

        for(let dp of domPath) {
            if(currentParent.tagName !== dp.parent) {
                throw new Error("DomPath invalid, should have seen "+dp.parent+" saw "+currentParent.tagName);
            }
            currentParent = Array.from(currentParent.childNodes)[dp.childIndex];
        }

        return currentParent;
    }

    /**
     * Create a fragment of the given type.
     * 
     * If no Fragment is registered for the given type, null is returned.
     *
     * @example
     * let myJSFragment = Fragment.create("text/javascript");
     *
     * @param {string} type the type of fragment to create
     * @returns {Fragments.Fragment} the created fragment, or null
     */
    static create(type) {
        if (!Fragment.fragmentTypes.has(type)) {
            console.error("Creating fragment of unregistered type:", type);
            return null;
        }

        let fragmentDom = cQuery("<code-fragment data-type='" + type + "'></code-fragment>");

        Fragment.setupFragment(fragmentDom);

        return fragmentDom.data("Fragment");
    }

    /**
     * Registers a new fragment type
     * @ignore
     * @param {string} fragmentClass the fragment type to register
     */
    static registerFragmentType(fragmentClass) {
        if (Fragment.fragmentTypes.has(fragmentClass.type())) {
            console.error("Already have registered fragment type:", fragmentClass.type());
            return;
        }
        Fragment.fragmentTypes.set(fragmentClass.type(), fragmentClass);

        return Fragment.loadUnknownFragments(fragmentClass.type());
    }

    /**
     * Unregisters a fragment type, this also triggers unload on all fragments of this type that is currently loaded
     * @ignore
     * @param {string} fragmentClass the fragment type to unregister
     */
    static unRegisterFragmentType(fragmentClass) {
        Fragment.fragmentTypes.delete(fragmentClass.type());

        //Go through all fragments of this type, and do stuff
        cQuery("code-fragment[data-type='" + fragmentClass.type() + "']").forEach((fragmentElement) => {
            let fragment = cQuery(fragmentElement).data("Fragment");

            if (fragment != null) {
                //Unload the fragment
                fragment.unload();
            }

            //Reinsert this fragment as unknown
            Fragment.saveUnknownFragment(fragmentElement, fragmentClass.type());
        });
    }

    /**
     * Sets up the given fragment
     * @private
     * @param {cQuery} fragment - the fragment to set up
     */
    static setupFragment(fragment) {
        if (fragment.data("Fragment") != null) {
            //Already setup as fragment
            return null;
        }

        let fragmentType = fragment[0].getAttribute("data-type");

        if (!Fragment.fragmentTypes.has(fragmentType)) {
            //Unknown fragment type

            if (fragmentType != null) {
                Fragment.saveUnknownFragment(fragment, fragmentType);
            }

            return null;
        }

        let fragmentClass = Fragment.fragmentTypes.get(fragmentType);
        return new fragmentClass(fragment);
    }

    /**
     * Tries to setup all current and future fragments on the DOM
     * @ignore
     */
    static async setupFragments() {
        let foundFragments = [];

        //Check fragments already in DOM
        cQuery("code-fragment").forEach((fragmentDom) => {
            fragmentDom = cQuery(fragmentDom);
            let fragment = Fragment.setupFragment(fragmentDom);

            if (fragment !== null) {
                foundFragments.push(fragment);
            }
        });

        await Fragment.runFragmentsLoaded();

        //Observe newly added fragments, and deleted fragments
        let observer = new MutationObserver(async (mutations) => {

            let foundFragments = [];

            mutations.forEach((mutation) => {
                Array.from(mutation.addedNodes).forEach((node) => {
                    node = cQuery(node);
                    if (node.is("code-fragment")) {
                        let fragment = Fragment.setupFragment(node);
                        if(fragment != null) {
                            foundFragments.push(fragment);
                        }
                    } else {
                        if (node[0].querySelector != null) {
                            node.find("code-fragment").forEach((child) => {
                                child = cQuery(child);
                                let fragment = Fragment.setupFragment(child);
                                if(fragment != null) {
                                    foundFragments.push(fragment);
                                }
                            });
                        }
                    }
                });
                Array.from(mutation.removedNodes).forEach((node) => {
                    if(node.matches != null && node.matches("code-fragment")) {
                        cQuery(node).data("Fragment").unload();
                    } else if(node.querySelector != null) {
                        node.querySelectorAll("code-fragment").forEach((child)=>{
                            cQuery(child).data("Fragment").unload();
                        });
                    }
                });
            });

            await Fragment.runFragmentsLoaded();
        });

        observer.observe(document, {
            attributes: false,
            subtree: true,
            childList: true
        });
    }

    /**
     * Loads all currently unloaded fragments
     * @ignore
     * @returns {Promise<void>} - Promise that resolves when all unloaded fragments are done loading
     */
    static async runFragmentsLoaded() {
        if(!Fragment.allInstalledRun) {
            return;
        }

        //Check if currently loading
        while (Fragment.currentlyLoadingFragments) {
            await new Promise((resolve) => {
                setTimeout(() => {
                    resolve();
                }, 0);
            });
        }

        Fragment.currentlyLoadingFragments = true;

        let unloadedFragments = Fragment.find("code-fragment").filter((fragment)=>{
            let isLoaded = fragment.isLoaded;
            fragment.isLoaded = true;
            return !isLoaded;
        });

        for(let fragment of unloadedFragments) {
            fragment.isLoaded = true;
            await fragment.onFragmentsLoaded();
        }

        Fragment.currentlyLoadingFragments = false;
    }

    /**
     * Saves the given fragment for later loading when its no longer unknown
     * @private
     * @param {cQuery} fragment - the fragment to save
     * @param {string} type - the type of the fragment
     */
    static saveUnknownFragment(fragment, type) {

        //Unpack cQuery/jQuery objects, we want unique check of Set to work.
        if (fragment[0] != null) {
            fragment = fragment[0];
        }

        let fragmentsOfType = Fragment.unknownFragments.get(type);

        if (fragmentsOfType == null) {
            fragmentsOfType = new Set();
            Fragment.unknownFragments.set(type, fragmentsOfType);
        }

        fragmentsOfType.add(fragment);
    }

    /**
     * Loads all unknown fragments of a given type
     * @private
     * @param {type} type the fragment type to load
     */
    static loadUnknownFragments(type) {
        let unknownFragments = Fragment.unknownFragments.get(type);

        if (unknownFragments != null) {

            let unknownFragmentsCopy = Array.from(unknownFragments);

            //Clear the Set, fragments will be readded if not handled
            unknownFragments.clear();

            unknownFragmentsCopy.forEach((fragment) => {
                let frag = Fragment.setupFragment(cQuery(fragment));
            });

            return Fragment.runFragmentsLoaded();
        }

        return Promise.resolve();
    }

    /**
     * Returns the first fragment that is found from the given query
     *
     * This is the equivalent of taking the first result of Fragment.find(query)
     *
     * @example
     * let myFragment = Fragment.one("#myFragment");
     *
     * @param {string|cQuery|Array|Node} query - The query used to find fragments. Can be a css selector, a cQuery object, a dom element or an array of dom elements.
     * @returns {Fragments.Fragment} - the found fragment, or null if none could be found
     */
    static one(query) {
        let fragments = Fragment.find(query);

        if (fragments.length > 0) {
            return fragments[0];
        }

        return null;
    }

    /**
     * Finds all fragments based on a given query
     *
     * @example
     * let fragments = Fragment.find(".someClass");
     *
     * @param {string|cQuery|Array|Node} query - The query used to find fragments. Can be a css selector, a cQuery object, a dom element or an array of dom elements.
     * @returns {Fragments.Fragment[]} The found fragments
     */
    static find(query) {
        let fragments = [];

        if (query != null) {
            if (typeof query === "string") {
                cQuery(query).forEach((result) => {
                    result = cQuery(result);

                    let fragment = result.data("Fragment");

                    if (fragment != null) {
                        fragments.push(fragment);
                    }
                });

            } else if (Array.isArray(query) || query instanceof Array) {
                query.forEach((item) => {
                    fragments = fragments.concat(Fragment.find(item));
                });

            } else if (typeof query === "object") {
                if (query instanceof Fragment) {
                    fragments.push(query);
                } else if (query instanceof HTMLElement) {
                    let fragment = cQuery(query).data("Fragment");
                    if (fragment != null) {
                        fragments.push(fragment);
                    }
                } else if (query instanceof NodeList) {
                    fragments = fragments.concat(Fragment.find(Array.from(query)));
                }
            }
        }

        return fragments;
    }

    static fromFragmentUUID(uuid) {
        for(let fragmentDom of cQuery("code-fragment")) {
            let fragment = cQuery(fragmentDom).data("Fragment");

            if(fragment != null && fragment.uuid === uuid.replace("_", "-")) {
                return fragment;
            }
        }

        return null;
    }



}; window.Fragment = Fragment;

Fragment.allInstalledRun = false;
Fragment.fragmentTypes = new Map();
Fragment.unknownFragments = new Map();
Fragment.disableAutorun = false;
Fragment.currentlyLoadingFragments = false;

Fragment.setupFragments();

wpm.onAllInstalled(()=>{
    Fragment.allInstalledRun = true;
    Fragment.runFragmentsLoaded();
});

</script>

                <script id="stackwalker-script" type="disabled">
/**
 *  StackWalker
 *  An exception parser that that tries to clean out useless info from
 *  browser stack traces and provide only Codestrates-relevant parts
 * 
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *    
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

/**
 * StackWalker can compactify stack traces to remove codestrates internal traces, thus making them easier to read
 */
class StackWalker {
    /**
     * Given a full stack trace, produces a reduced stacktrace where only codestrate
     * stack markers are used instead of every method invocation.
     * 
     * @param {string[]} stack
     * @returns {string[]} The cleaned stack trace array
     */
    static compactify(stack){
        //Attempt to clean up some codestrates internal method code
        let cleanedStack = [];

        //If find pattern of Function.execute, codeStratesEvalInContext, eval, remove all 3
        stackLoop: for(let i = 0; i<stack.length; i++) {
            let si = stack[i];

            cleanPatternLoop: for(let cleanPattern of StackWalker.stackCleanPatterns) {
                try {
                    for(let j = 0; j<cleanPattern.pattern.length; j++) {
                        let pattern = cleanPattern.pattern[j];
                        let method = stack[i+j].method;

                        if(pattern.startsWith("~")) {
                            pattern = pattern.substring(1);
                            if(method.indexOf(pattern) === -1) {
                                //This pattern did not match
                                continue cleanPatternLoop;
                            }
                        } else {
                            if(method !== pattern) {
                                //This pattern did not match
                                continue cleanPatternLoop;
                            }
                        }
                    }

                    i += cleanPattern.pattern.length-1;

                    if(cleanPattern.output != null) {
                        let method = cleanPattern.output.method;

                        if(typeof method === "function") {
                            method = method(si);
                        }

                        cleanedStack.push({
                            method: method,
                            lineNumber: cleanPattern.output.lineNumber?si.lineNumber:null
                        });
                    }

                    continue stackLoop;
                } catch(e) {

                }
            }

            cleanedStack.push(si);
        }

        return cleanedStack;
    }
}

window.StackWalker = StackWalker;

StackWalker.stackCleanPatterns = [];

StackWalker.stackCleanPatterns.push({
    pattern: [
        "eval",
        "codeStratesEvalInContext",
        "Function.execute"
    ],
    output: null
});

StackWalker.stackCleanPatterns.push({
    pattern: [
        "codeStratesEvalInContext",
        "Function.execute",
        "~.require"
    ],
    output: null
});

StackWalker.stackCleanPatterns.push({
    pattern: [
        "_setup",
        "_start",
        "new _",
        "internalP5Function"
    ],
    output: null
});

StackWalker.stackCleanPatterns.push({
    pattern: [
        "_.n.default.redraw",
        "_draw"
    ],
    output: null
});

StackWalker.stackCleanPatterns.push({
    pattern: [
        "~.require",
        "~.onFragmentsLoaded",
        "Function.runFragmentsLoaded"
    ],
    output: {
        method: "<Codestrate Autostart>",
        lineNumber: false
    }
});

StackWalker.stackCleanPatterns.push({
    pattern: [
        "~.require",
        "eval",
        "eval",
        "Set.forEach",
        "Function.triggerEvent",
        "MenuItem.onAction",
        "MenuItem.triggerOnAction",
        "Menu.handleItemAction",
        "HTMLDivElement.eval",
        "h.a.emit",
        "Object.notifySelected",
        "_.handleItemAction",
        "HTMLDivElement.handleItemAction_",
        "d.a.emit",
        "Object.notifyAction",
        "d.handleClick",
        "d.handleClickEvent_"
    ],
    output: {
        method: "<Codestrate Run>",
        lineNumber: false
    }
});

StackWalker.stackCleanPatterns.push({
    pattern: [
        "TypeScriptAutoRunInternal",
        "eval",
        "Object.execCb",
        "e.check",
        "eval",
        "eval",
        "eval",
        "each",
        "emit",
        "e.check",
        "enable",
        "e.init",
        "a",
        "Object.completeLoad",
        "HTMLScriptElement.onScriptLoad"
    ],
    output: {
        method: "<Codestrate Autorun>",
        lineNumber: false
    }
});

StackWalker.stackCleanPatterns.push({
    pattern: [
        "eval",
        "Object.execCb",
        "e.check",
        "eval",
        "eval",
        "eval",
        "each",
        "emit",
        "e.check",
        "enable",
        "e.init",
        "a",
        "Object.completeLoad",
        "HTMLScriptElement.onScriptLoad"
    ],
    output: {
        method: "<Codestrate Run>",
        lineNumber: false
    }
});

StackWalker.stackCleanPatterns.push({
    pattern: [
        "eval",
        "Object.execCb",
        "e.check",
        "enable",
        "e.init",
        "eval"
    ],
    output: {
        method: "<Codestrate Run>",
        lineNumber: false
    }
});

StackWalker.stackCleanPatterns.push({
    pattern: [
        "P5Fragment.require",
        "P5Fragment.createAutoDom",
        "P5Fragment.insertAutoDom",
        "eval",
        "eval",
        "Array.forEach",
        "P5Fragment.triggerFragmentChanged",
        "P5Fragment.mutationCallback",
        "MutationObserver.mutationHandler"
    ],
    output: {
        method: "<Codestrate Autorun>",
        lineNumber: false
    }
});

StackWalker.stackCleanPatterns.push({
    pattern: [
        "P5Fragment.require",
        "P5Fragment.createAutoDom",
        "P5Fragment.insertAutoDom",
        "P5Fragment.onFragmentsLoaded",
        "Function.runFragmentsLoaded"
    ],
    output: {
        method: "<Codestrate Autorun>",
        lineNumber: false
    }
});

StackWalker.stackCleanPatterns.push({
    pattern: [
        "P5Fragment.require",
        "P5Fragment.createAutoDom",
        "P5Fragment.insertAutoDom",
        "eval",
        "eval",
        "Array.forEach",
        "P5Fragment.triggerFragmentChanged",
        "P5Fragment.executeObserverless",
        "CodemirrorEditor.handleModelChanged",
        "eval",
        "signal",
        "endOperation_finish",
        "endOperations",
        "at",
        "finishOperation",
        "endOperation",
        "runInOp",
        "~",
        "HTMLTextAreaElement.<anonymous>"
    ],
    output: {
        method: "<Codestrate Autorun>",
        lineNumber: false
    }
});

StackWalker.stackCleanPatterns.push({
    pattern: [
        "P5Fragment.require",
        "P5Fragment.createAutoDom",
        "P5Fragment.insertAutoDom",
        "eval",
        "eval",
        "Array.forEach",
        "P5Fragment.triggerFragmentChanged",
        "P5Fragment.executeObserverless",
        "CodemirrorEditor.handleModelChanged",
        "eval",
        "signal",
        "endOperation_finish",
        "endOperations",
        "at",
        "finishOperation",
        "endOperation",
        "HTMLTextAreaElement.<anonymous>"
    ],
    output: {
        method: "<Codestrate Autorun>",
        lineNumber: false
    }
});

StackWalker.stackCleanPatterns.push({
    pattern: [
        "~CS_ASYNC_fragment_"
    ],
    output: {
        method: (si) =>{
            //Internal fragment
            let fragmentUUID = si.method.substring(si.method.indexOf("CS_ASYNC_fragment_")+9).replace("_", "-");
            let fragment = Fragment.fromFragmentUUID(fragmentUUID);

            let attrName = fragment.html[0].getAttribute("name");
            let attrId = fragment.html[0].getAttribute("id");

            let name = (attrName != null && attrName.trim() !== "" ? attrName : "code-fragment");

            if(attrId != null && attrId.trim() !== "") {
                name += "#"+attrId;
            }

            return fragment.constructor.name+" "+name;
        },
        lineNumber: true
    }
})

/**
 * A StackTrace object
 * @memberof StackWalker
 */
class StackTrace {
    constructor(name, stack, extraReason) {
        /** @member {string} */
        this.name = name;
        /** @member {string[]} */
        this.stack = stack;
        /** @member {string} */
        this.extraReason = extraReason;
    }
};

window.StackWalker.StackTrace = StackTrace;

</script>

            </div>
            <div class="package" id="fragment_js">
                <script id="descriptor-script" type="descriptor">
{
    "description": "Javascript Fragment for Codestrates",
    "dependencies": [
        "#fragment_core",
        "#js-eval-engine"
    ],
    "license": "Apache 2.0",
    "assets": [],
    "version": "1"
}

</script>

                <script id="fragment_js-script" type="disabled">
/**
 *  JavascriptFragment
 *  Fragments with js that can be executed
 * 
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *    
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

/* global webstrate, cQuery, Fragment, wpm, JsEvalEngine */

wpm.onRemoved(()=>{
    Fragment.unRegisterFragmentType(JavascriptFragment);
});

/**
 * A fragment that contains js code
 *
 * Supports auto - executes require() on load
 * @extends Fragments.Fragment
 * @hideconstructor
 * @memberof Fragments
 */
class JavascriptFragment extends Fragment {
    constructor(html) {
        super(html);
    }

    /**
     * An object describing the options for require.
     *
     * Example:
     * <pre><code>{
     *     context: {
     *         someVariable: "test"
     *     },
     *     customConsole: {
     *         log: (...messages)=>{
     *              console.log("Custom:", ...messages);
     *         }
     *     }
     * }
     * </code></pre>
     *
     * @typedef {Object} JavascriptFragment~RequireOptions
     * @property {Object} [context] - The context to pass to the javascript environment
     * @property {Object} [customConsole] - A custom object used instead of window.console, ie. to make custom log methods.
     */

    /**
     * Evaluates the javascript inside this fragment and returns the export object
     *
     * @example
     * let exportedObject = Fragment.one("#myJsFragment").require();
     *
     * @param {JavascriptFragment~RequireOptions} [options] - Object containing any custom options.
     * @returns {Promise<Object>}
     */
    require(options = {}) {
        return JsEvalEngine.execute(this.raw, options, this);;
    }

    async onFragmentsLoaded() {
        if(this.auto && !Fragment.disableAutorun) {
            await this.require();
        }
    }

    supportsRun() {
        return true;
    }
    
    supportsAuto() {
        return true;
    }

    static type() {
        return "text/javascript";
    }
}; window.JavascriptFragment = JavascriptFragment;

Fragment.registerFragmentType(JavascriptFragment);

</script>

            </div>
            <div class="package" id="fragment_html">
                <script id="descriptor-script" type="descriptor">
{
    "description": "HTML Fragment support for Codestrates",
    "dependencies": [
        "#fragment_core"
    ],
    "license": "Apache 2.0",
    "assets": [],
    "version": "1"
}

</script>

                <script id="fragment_html-script" type="disabled">
/**
 *  HtmlFragment
 *  Fragments with html that can be injected into the page in the same place
 * 
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *    
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

/* global webstrate, cQuery, Fragment, wpm */

wpm.onRemoved(()=>{
    Fragment.unRegisterFragmentType(HtmlFragment);
});

/**
 * A fragment containing html
 *
 * Supports autodom insertion
 * @extends Fragments.Fragment
 * @hideconstructor
 * @memberof Fragments
 */
class HtmlFragment extends Fragment {
    constructor(html) {
        super(html);
    }
    
    supportsAutoDom() {
        return true;
    }

    /**
     * Get a document fragment containing the html from this fragment
     *
     * @example
     * let documentFragment = Fragment.one("#myHtmlFragment").require();
     *
     * @returns {Promise<DocumentFragment>}
     */
    async require(options) {
        let domFragment = document.createDocumentFragment();

        let dom = cQuery("<div>"+this.raw+"</div>");

        Array.from(dom[0].childNodes).forEach((node)=>{
            domFragment.appendChild(node);
        });
        
        return domFragment;
    }
    
    getTextContentNode() {
        if(this.html[0].childNodes.length > 1 || (this.html[0].firstChild != null && !(this.html[0].firstChild instanceof Text))) {
            //We have at least one child, first of those is not a Text node, convert
            let textNode = document.createTextNode("");
            let content = this.html[0].innerHTML;
            this.html[0].innerHTML = "";
            this.html[0].appendChild(textNode);
            textNode.nodeValue = content;
            console.log("Converted HTML to single textNode");
        }
        
        return super.getTextContentNode();
    }
    
    static type() {
        return "text/html";
    }
}; window.HtmlFragment = HtmlFragment;

Fragment.registerFragmentType(HtmlFragment);

</script>

            </div>
            <div class="package" id="fragment_json">
                <script id="descriptor-script" type="descriptor">
{
    "description": "JSON-data Fragment for Codestrates",
    "dependencies": [
        "#fragment_core"
    ],
    "license": "Apache 2.0",
    "assets": [],
    "version": "1"
}

</script>

                <script id="fragment_json-script" type="disabled">
/**
 *  JSONFragment
 *  Fragments with json data that can be included
 * 
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *    
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

/* global webstrate, cQuery, Fragment, wpm */

wpm.onRemoved(()=>{
    Fragment.unRegisterFragmentType(JSONFragment);
});

/**
 * A fragment that contains json
 *
 * @extends Fragments.Fragment
 * @memberof Fragments
 * @hideconstructor
 */
class JSONFragment extends Fragment {
    constructor(html) {
        super(html);
    }

    /**
     * Get the contained json as an object
     * @example
     * let jsonElement = Fragment.one("#myJsonFragment").require();
     * @returns {Promise<Object>} - Promise that resolves to the json object with the json from this fragment.
     */
    async require(options = {}) {
        return JSON.parse(this.raw);
    }

    static type() {
        return "application/json";
    }
}; window.JSONFragment = JSONFragment;

Fragment.registerFragmentType(JSONFragment);

</script>

            </div>
            <div class="package" id="fragment_latex">
                <script id="descriptor-script" type="descriptor">
{
    "description": "LaTeX Fragment for Codestrates",
    "dependencies": [
        "#fragment_core",
        "/wpm_js_libs/?raw #latex_js"
    ],
    "license": "Apache 2.0 (w/MIT)",
    "assets": [],
    "version": "1"
}

</script>

                <script id="fragment_latex-script" type="disabled">
/**
 *  LaTeXFragment
 *  Compose LaTeX documents in Codestrates
 * 
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *    
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

/* global webstrate, cQuery, Fragment, fetchSassWorkerBlob, URL, LatexJSLibraryPath, wpm */

wpm.onRemoved(()=>{
    Fragment.unRegisterFragmentType(LaTeXFragment);
});

/**
 * A fragment containing latex
 *
 * Supports autodom insertion
 * @extends Fragments.Fragment
 * @hideconstructor
 * @memberof Fragments
 */
class LaTeXFragment extends Fragment {
    constructor(html) {
        super(html);
    }

    /**
     * Render the LaTeX of this fragment to html
     * @example
     * let latexDiv = Fragment.one("#myLaTeXFragment").require();
     * @returns {Promise<HTMLDivElement>} - Promise that resolves to a div containing the LaTeX rendered as html. Warning the div also contains the needed styles to render the LaTeX correctly, the styles are not namespaced.
     */
    require(options) {
        let self = this;

        return new Promise((resolve, reject) => {
            import(LatexJSLibraryPath+"/latex.esm.js").then((latexjs)=>{
                try {
                    let generator = new latexjs.default.HtmlGenerator({ hyphenate: false });

                    let latexDoc = latexjs.default.parse(self.raw, { generator: generator });

                    let root = document.createElement("div");
                    root.appendChild(latexDoc.stylesAndScripts(LatexJSLibraryPath));
                    root.appendChild(latexDoc.domFragment());
                    resolve(root);
                } catch(e) {
                    reject(e);
                }
            });
        });
    }

    supportsAutoDom() {
        return true;
    }

    async createAutoDom() {
        let content = await this.require();

        let iframe = document.createElement("iframe");

        iframe.srcdoc = content.innerHTML;
        iframe.classList.add("latex");

        //Setup iframe height to be equal to its content.
        iframe.onload = ()=>{
            iframe.height = "";
            iframe.height = iframe.contentWindow.document.body.scrollHeight;
        };

        //Fix for board not being visible on load
        let observer = new MutationObserver((mutation)=>{
            if(iframe.offsetWidth > 0) {
                iframe.height = "";
                iframe.height = iframe.contentWindow.document.body.scrollHeight;
                observer.disconnect();
            }
        });
        observer.observe(document.body, {
            attributes: true,
            childList: true,
            subtree: true
        });

        return iframe;
    }

    static type() {
        return "text/x-latex";
    }
}; window.LaTeXFragment = LaTeXFragment;

Fragment.registerFragmentType(LaTeXFragment);

</script>

                <style id="base-style">
iframe.latex {
    border: 0;
    display: block;
}
</style>

            </div>
            <div class="package" id="fragment_wpm-descriptor">
                <script id="descriptor-script" type="descriptor">
{
    "description": "WPM package descriptor Fragment for Codestrates",
    "dependencies": [
        "#fragment_core"
    ],
    "license": "Apache 2.0",
    "assets": [],
    "version": "1"
}

</script>

                <script id="fragment_descriptor-script" type="disabled">
/**
 *  DescriptorFragment
 *  Support for WPM package descriptors in Codestrates
 * 
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *    
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

/* global webstrate, cQuery, Fragment, wpm, WPMv2 */

wpm.onRemoved(() => {
    Fragment.unRegisterFragmentType(DescriptorFragment);
});

/**
 * A fragment containing a WPM descriptor
 *
 * @extends Fragments.Fragment
 * @hideconstructor
 * @memberof Fragments
 */
class DescriptorFragment extends Fragment {
    constructor(html) {
        super(html);
    }

    getTextContentNode() {
        let self = this;
        
        let descriptor = this.html.find("wpm-descriptor");

        if (descriptor.length === 0) {
            this.executeObserverless(() => {
                descriptor = cQuery(document.createElement("wpm-descriptor"));
                self.html.append(descriptor);
                WPMv2.stripProtection(descriptor);
                descriptor[0].textContent = `{
    "description": "",
    "dependencies": [
    ],
    "assets": [],
    "version": "1"
}`;
            },null, true);
        }

        this.checkTextContentNode(descriptor[0]);

        return descriptor[0];
    }

    /**
     *  A json object containing the descriptor json
     * @example
     * let descriptorJson = Fragment.one("#myDescriptorFragment").require();
     * @returns {Promise<Object>}
     */
    async require(options = {}) {
        return JSON.parse(this.raw);
    }

    static type() {
        return "wpm/descriptor";
    }
}; 

window.DescriptorFragment = DescriptorFragment;
Fragment.registerFragmentType(DescriptorFragment);

</script>

            </div>
            <div class="package" id="fragment_css">
                <script id="descriptor-script" type="descriptor">
{
    "description": "CSS Fragment for Codestrates",
    "dependencies": [
        "#fragment_core"
    ],
    "license": "Apache 2.0",
    "assets": [],
    "version": "1"
}

</script>

                <script id="fragment_css-script" type="disabled">
/**
 *  CSSFragment
 *  Fragments with css that can be injected into the page
 * 
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *    
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/


/* global webstrate, cQuery, Fragment, wpm */
wpm.onRemoved(()=>{
    Fragment.unRegisterFragmentType(CSSFragment);
});

/**
 * A fragment that contains css code
 *
 * Supports autodom insertion
 * @hideconstructor
 * @memberof Fragments
 * @extends Fragments.Fragment
 */
class CSSFragment extends Fragment {
    constructor(html) {
        super(html);
    }

    /**
     * Creates a new style element with the styles represented by this css fragment inserted.
     *
     * @example
     * let styleElm = Fragment.one("#myCssFragment").require();
     *
     * @returns {Promise<HTMLStyleElement>} - Promise that resolves to the style element
     */
    async require(options = {}) {
        let style = document.createElement("style");

        style.textContent = this.raw;

        return style;
    }

    supportsAutoDom() {
        return true;
    }

    static type() {
        return "text/css";
    }
}; window.CSSFragment = CSSFragment;

Fragment.registerFragmentType(CSSFragment);

</script>

            </div>
            <div class="package" id="fragment_scss">
                <script id="descriptor-script" type="descriptor">
{
    "description": "SCSS Fragment for Codestrates",
    "dependencies": [
        "#fragment_core",
        "/wpm_js_libs/?raw #sass_js"
    ],
    "license": "Apache 2.0 (w/MIT)",
    "assets": [],
    "version": "1"
}

</script>

                <script id="fragment_scss-script" type="disabled">
/**
 *  SCSSFragment
 *  Compose and compile SCSS-scripts in Codestrates
 * 
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *    
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

/* global webstrate, cQuery, Fragment, fetchSassWorkerBlob, URL, wpm */

wpm.onRemoved(() => {
    Fragment.unRegisterFragmentType(SCSSFragment);
});

/**
 * A fragment containing scss
 *
 * Supports autodom insertion
 * @extends Fragments.Fragment
 * @hideconstructor
 * @memberof Fragments
 */
class SCSSFragment extends Fragment {
    constructor(html) {
        super(html);
    }

    /**
     * Create a style element containing the css rules resulting from compiling this fragments scss
     * @example
     * let styleElm = Fragment.one("#myScssFragment").require();
     * @returns {Promise<HTMLStyleElement>}
     */
    require(options) {
        let self = this;

        return new Promise((resolve, reject) => {
            requirejs(["sass/sass"], (Sass)=>{
                let workerPromise = new Promise((resolve, reject)=>{
                    if(self.sassCompiler == null) {
                        fetchSassWorkerBlob().then((blob) => {
                            self.sassCompiler = new Sass(URL.createObjectURL(blob));
                            resolve();
                        });
                    } else {
                        resolve();
                    }
                });

                workerPromise.then(()=>{
                    self.sassCompiler.compile(self.raw, (result) => {
                        if (result.status === 0) {
                            let style = document.createElement("style");

                            style.textContent = result.text;

                            resolve(style);
                        } else {
                            reject(result.message);
                        }
                    });
                });
            });
        });
    }

    supportsAutoDom() {
        return true;
    }

    static type() {
        return "text/x-scss";
    }
}; window.SCSSFragment = SCSSFragment;

Fragment.registerFragmentType(SCSSFragment);

</script>

            </div>
            <div class="package" id="fragment_svg">
                <script id="descriptor-script" type="descriptor">
{
    "description": "SVG fragment type",
    "dependencies": [
        "#fragment_core"
    ],
    "license": "Apache 2.0",
    "assets": [],
    "version": "1"
}

</script>

                <script id="fragment_svg-script" type="disabled">
/**
 *  SVGFragment
 *  SVG support in Codestrates
 * 
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *    
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

/* global webstrate, cQuery, Fragment, wpm */

wpm.onRemoved(() => {
    Fragment.unRegisterFragmentType(SVGFragment);
});

/**
 * A fragment containing SVG
 *
 * Supports autodom insertion
 * @extends Fragments.Fragment
 * @hideconstructor
 * @memberof Fragments
 */
class SVGFragment extends Fragment {
    constructor(html) {
        super(html);
    }

    /**
     * Creates an svg element containing the svg inside the fragment.
     * @example
     * let svgElm = Fragment.one("#mySvgFragment").require();
     * @returns {Promise<SVGElement>}
     */
    async require(options = {}) {
        return cQuery(this.raw);
    }

    supportsAutoDom() {
        return true;
    }

    static type() {
        return "image/svg+xml";
    }
};  window.SVGFragment = SVGFragment;

Fragment.registerFragmentType(SVGFragment);

</script>

            </div>
            <div class="package" id="fragment_python">
                <script id="descriptor-script" type="descriptor">
{
    "description": "Python Fragment for Codestrates",
    "dependencies": [
        "#fragment_core"
    ],
    "optionalDependencies": [
        "/wpm_js_libs/?raw #brython"
    ],
    "license": "Apache 2.0 (w/BSD-3)",
    "assets": [],
    "version": "1"
}

</script>

                <script id="fragment_python-script" type="disabled">
/**
 *  PythonFragment
 *  Execute python-code with Codestrates
 * 
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *    
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

/* global webstrate, cQuery, Fragment, pyodide, languagePluginLoader, Promise, wpm */

wpm.onRemoved(()=>{
    Fragment.unRegisterFragmentType(PythonFragment);
});

/**
 * A fragment containing python code

 * Supports auto - executes require() on load
 * @extends Fragments.Fragment
 * @hideconstructor
 * @memberof Fragments
 */
class PythonFragment extends Fragment {
    constructor(html) {
        super(html);
    }

    /**
     * Evaluates the python code inside this fragment and returns the exported object
     * @example
     * let exportedObject = Fragment.one("#myPythonFragment").require();
     * @returns {Promise<Object>}
     */
    async require(options) {
        let self = this;
        try {
            if (typeof $B === "undefined" ) {
                console.log("Fetching Brython package...");
                await wpm.require("brython");

                //Magic?
                $B.meta_path=$B.$meta_path.slice();
                if(!$B.use_VFS){$B.meta_path.shift()}
            }

            let code = self.raw;

            let paddedCode = "";

            code.split("\n").forEach((line) => {
                paddedCode += "\t" + line + "\n";
            });

            let module_name = UUIDGenerator.generateUUID("", 25);

            let scopedCode = `def codestrates_python_scope():
    from browser import window, load, aio
    
    def asyncComplete(*args):
        asyncPythonComplete()
    
    async def asyncWrapper():
    ${paddedCode}
    aio.run(asyncWrapper(), onsuccess=asyncComplete)
    
codestrates_python_scope()`;

            //Generate code
            let jsCode = $B.py2js(scopedCode, module_name, module_name).to_js();

            let localsName = "$locals_"+module_name;

            //Convert code to actually working code? Something about libs break if not done like this

            let js = jsCode.split("\n");

            js.splice(0, 3, `(__BRYTHON__, ${localsName}) => { 
  __BRYTHON__.$setattr(__BRYTHON__,"curdir","./")
  __BRYTHON__.$setattr(__BRYTHON__,"debug",1)
  var None;
  var $B = __BRYTHON__;
        ` + __BRYTHON__.InjectBuiltins());

            js.push("}");

            var script = js.join("\n");

            let context = {
                exports: {},
                console: JsEvalEngine.defaultOptions(this).customConsole,
            };

            return new Promise((resolve, reject)=>{
                context.asyncPythonComplete = ()=>{
                    resolve(context.exports);
                }

                eval(script)(__BRYTHON__, context);
            }).catch((e)=>{
                console.error(e);
            });


        } catch(e) {
            console.error(e);
        }
    }

    static parseErrorStack(name, stack, fragment) {
        let scopeSeen = false;

        let lines = stack.split("\n").filter((line)=>{
            if(line.indexOf("codestrate_python_scope") !== -1) {
                scopeSeen = true;
            }

            //Ommit all js stack lines
            return scopeSeen && line.trim() !== "" && !line.trim().startsWith("at ");
        });

        let extraReason = lines.pop();

        let parsedStack = [];

        lines.forEach((line)=>{
            let lineNumber = parseInt(line.match(/line (\d+),/)[1]);
            let method = line.match(/, in (.*)/)[1];

            if(method === "codestrate_python_scope") {
                //Internal fragment
                let attrName = fragment.html[0].getAttribute("name");
                let attrId = fragment.html[0].getAttribute("id");

                let name = (attrName != null && attrName.trim() !== "" ? attrName : "code-fragment");

                if(attrId != null && attrId.trim() !== "") {
                    name += "#"+attrId;
                }

                method = fragment.constructor.name+" "+name;
            }

            parsedStack.push({
                lineNumber: lineNumber-1,
                method: method
            })
        });

        parsedStack.reverse();

        return new StackWalker.StackTrace(name, parsedStack, extraReason);
    }

    onFragmentsLoaded() {
        if(this.auto && !Fragment.disableAutorun) {
            this.require();
        }
    }

    supportsAuto() {
        return true;
    }
    
    supportsRun() {
        return true;
    }

    static type() {
        return "text/python";
    }
}; window.PythonFragment = PythonFragment;

Fragment.registerFragmentType(PythonFragment);

</script>

            </div>
            <div class="package" id="fragment_markdown">
                <script id="descriptor-script" type="descriptor">
{
    "description": "Markdown Fragment for Codestrates",
    "dependencies": [
        "#fragment_core",
        "/wpm_js_libs/?raw #Showdown"
    ],
    "license": "Apache 2.0 (w/MIT)",
    "assets": [],
    "version": "1"
}

</script>

                <script id="fragment_markdown-script" type="disabled">
/**
 *  MarkdownFragment
 *  Compose markdown-code with Codestrates
 * 
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *    
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/


/* global webstrate, cQuery, Fragment, wpm */

wpm.onRemoved(()=>{
    Fragment.unRegisterFragmentType(MarkdownFragment);
});

/**
 * A fragment containing markdown
 *
 * Supports autodom insertion
 * @extends Fragments.Fragment
 * @hideconstructor
 * @memberof Fragments
 */
class MarkdownFragment extends Fragment {
    constructor(html) {
        super(html);
    }

    /**
     * Converts the markdown inside this fragment to html
     * @example
     * let renderedMarkdown = Fragment.one("#myMarkdownFragment").require();
     * @returns {Promise<HTMLElement>}
     */
    require(options) {
        return new Promise((resolve, reject)=>{
            requirejs(["showdown/showdown.min"], (showdown)=>{
                resolve(new showdown.Converter({
                    "strikethrough": true,
                    "tables": true,
                    "smoothLivePreview": true,
                    "openLinksInNewWindow": true,

                }).makeHtml(this.raw));
            });
        });
    }

    supportsAutoDom() {
        return true;
    }

    static type() {
        return "text/markdown";
    }
};window.MarkdownFragment = MarkdownFragment;

Fragment.registerFragmentType(MarkdownFragment);

</script>

            </div>
            <div class="package" id="fragment_ts">
                <script id="descriptor-script" type="descriptor">
{
    "description": "Typescript Fragment for Codestrates",
    "dependencies": [
        "#fragment_core",
        "#js-eval-engine",
        "/wpm_js_libs/?raw #typescript"
    ],
    "license": "Apache 2.0",
    "assets": [],
    "version": "1"
}

</script>

                <script id="fragment_ts-script" type="disabled">
/**
 *  TypescriptFragment
 *  Write typescript code and execute it in Codestrates
 * 
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *    
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

/* global webstrate, cQuery, Fragment, wpm */

wpm.onRemoved(() => {
    Fragment.unRegisterFragmentType(TypescriptFragment);
});

/**
 * A fragment containing TypeScript code
 *
 * Supports auto - executes require() on load
 * @extends Fragments.Fragment
 * @hideconstructor
 * @memberof Fragments
 */
class TypescriptFragment extends Fragment {
    constructor(html) {
        super(html);
    }

    /**
     * Evaluates the TypeScript code inside this fragment and returns the export object
     * @example
     * let exportedObject = Fragment.one("#myTypescriptFragment").require();
     * @param {JavascriptFragment~RequireOptions} [options] - Object containing any custom options.
     * @returns {Promise<Object>}
     */
    async require(options = {}) {
        let self = this;

        try {
            let exports = await new Promise((resolve, reject) => {
                requirejs(["typescript/typescript"], () => {
                    let typeScriptCode = JsEvalEngine.wrapInAsync(this.raw, "TypeScriptInternalAsync");

                    let result = ts.transpileModule(typeScriptCode, {
                        compilerOptions: {module: ts.ModuleKind.ES6, target: "ES2017"}
                    });

                    //Clean one layer of async function
                    let codeLines = result.outputText.trim().split("\n");
                    codeLines.splice(0, 1);
                    codeLines.pop();
                    let runCode = codeLines.join("\n");

                    if(options.autoRun) {
                        (function TypeScriptAutoRunInternal() {
                            try {
                                JsEvalEngine.execute(runCode, options, self).then((exports) => {
                                    resolve(exports);
                                }).catch((e) => {
                                    console.error(e);
                                    reject();
                                });
                            } catch (e) {
                                console.error("Error in typescript:", e);
                                reject();
                            }
                        })();
                    } else {
                        try {
                            JsEvalEngine.execute(runCode, options, self).then((exports) => {
                                resolve(exports);
                            }).catch((e) => {
                                console.error(e);
                                reject();
                            });
                        } catch (e) {
                            console.error("Error in typescript:", e);
                            reject();
                        }
                    }

                });
            });

            return exports;
        } catch(e) {
        }
    }

    onFragmentsLoaded() {
        if(this.auto && !Fragment.disableAutorun) {
            this.require({
                autoRun: true
            });
        }
    }

    supportsAuto() {
        return true;
    }
    
    supportsRun() {
        return true;
    }

    static type() {
        return "text/x-typescript";
    }
}; window.TypescriptFragment = TypescriptFragment;

Fragment.registerFragmentType(TypescriptFragment);

</script>

            </div>
            <div class="package" id="fragment_ruby">
                <script id="descriptor-script" type="descriptor">
{
    "description": "Ruby Fragment for Codestrates",
    "dependencies": [
        "#fragment_core",
        "#js-eval-engine",
        "/wpm_js_libs/?raw #opal"
    ],
    "license": "Apache 2.0 (w/MIT)",
    "assets": [],
    "version": "1"
}

</script>

                <script id="fragment_ruby-script" type="disabled">
/**
 *  RubyFragment
 *  Execute ruby-code with Codestrates
 * 
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *    
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

/* global webstrate, cQuery, Fragment, Promise, wpm, Opal */
wpm.onRemoved(() => {
    Fragment.unRegisterFragmentType(RubyFragment);
});

/**
 * A fragment containing ruby code
 *
 * Supports auto - executes require() on load
 * @hideconstructor
 * @memberof Fragments
 * @extends Fragments.Fragment
 */
class RubyFragment extends Fragment {
    constructor(html) {
        super(html);
    }

    /**
     * Evaluates the ruby inside this fragment and returns the export object
     * @example
     * let exportedObject = Fragment.one("#myRubyFragment").require();
     * @param {JavascriptFragment~RequireOptions} [options] - Object containing any custom options.
     * @returns {Promise<Object>}
     */
    require(options = {}) {
        let self = this;

        return new Promise(async (resolve, reject) => {
            if (!OpalInitialized) {
                await wpm.requireExternal(OpalLibraryPath+"opal.min.js");
                await wpm.requireExternal(OpalLibraryPath+"opal-parser.min.js");
                await wpm.requireExternal(OpalLibraryPath+"native.min.js");

                Opal.load("opal-parser");
                OpalInitialized = true;
                console.log("Opal loaded!");
            }

            let rubyCode = self.raw;

            //Detect any used requires, and make sure they are available
            for(let require of Array.from(rubyCode.matchAll(/require '(.*)'/g)).map((match)=>{
                return OpalLibraryPath+match[1]+".min.js";
            })) {
                await wpm.requireExternal(require);
            }

            try {
                let exportsCode = `
                    require 'native'
                    exports = Native(\`rubyExports\`)
                    
                    ${rubyCode}`;

                let compiledCode = Opal.compile(exportsCode);

                let context = {
                    rubyExports: {}
                };

                if(options.context != null) {
                    context = Object.assign({}, context, options.context);
                }

                resolve(JsEvalEngine.execute(compiledCode, {
                    context: context,
                    exportsName: "rubyExports"
                }, self));
            } catch(e) {
                let parsedStack = JsEvalEngine.parseErrorStack(e.name, e.stack);
                EventSystem.triggerEvent("Codestrates.Fragment.Error", {
                    messages: ["Error in ruby: ", parsedStack],
                    fragment: self
                });
                reject();
            }
        });
    }

    onFragmentsLoaded() {
        if (this.auto && !Fragment.disableAutorun) {
            this.require();
        }
    }

    supportsAuto() {
        return true;
    }
    
    supportsRun() {
        return true;
    }

    static type() {
        return "text/ruby";
    }
}; window.RubyFragment = RubyFragment;

Fragment.registerFragmentType(RubyFragment);

</script>

            </div>
            <div class="package" id="fragment_lua">
                <script id="descriptor-script" type="descriptor">
{
    "description": "Lua Fragment for Codestrates",
    "dependencies": [
        "#fragment_core",
        "#js-eval-engine",
        "/wpm_js_libs/?raw #fengari"
    ],
    "license": "Apache 2.0 (w/MIT)",
    "assets": [],
    "version": "1"
}

</script>

                <script id="fragment_lua-script" type="disabled">
/**
 *  LuaFragment
 *  Execute Lua code in Codestrates
 * 
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *    
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

/* global webstrate, cQuery, Fragment, wpm, JsEvalEngine */

wpm.onRemoved(()=>{
    Fragment.unRegisterFragmentType(LuaFragment);
});

/**
 * A fragment that contains lua code
 * @hideconstructor
 * @memberof Fragments
 */
class LuaFragment extends Fragment {
    constructor(html) {
        super(html);
    }

    async require(options = {}) {
        let self = this;

        return new Promise((resolve, reject)=>{
            requirejs(["fengari/fengari-web"], (fengari)=>{
                let exports = {};

                function resumeCorutine(L, numArgs) {
                    try {
                        //Start corutine
                        let retVal = fengari.lua.lua_resume(L, null, numArgs);

                        if(retVal === fengari.lua.LUA_OK) {
                            resolve(exports);
                        } else if(retVal !== fengari.lua.LUA_YIELD) {
                            let res = null;
                            for (let i=1; i<=fengari.lua.lua_gettop(L); i++) {
                                let ud = fengari.lua.lua_touserdata(L, i);

                                if(ud != null && ud.data != null && ud.data instanceof Error) {
                                    res = ud.data;
                                    break;
                                }
                            }

                            if(res == null) {
                                res = new Error( fengari.lua.lua_tojsstring(L, -1));
                            }

                            let parsedStack = LuaFragment.parseErrorStack(res, self);
                            EventSystem.triggerEvent("Codestrates.Fragment.Error", {
                                messages: ["Error in lua: ", parsedStack],
                                fragment: self
                            });
                            console.error(res);
                            reject(res);
                        }
                    } catch(e) {
                        console.error(e);
                        let parsedStack = new StackWalker.StackTrace("", [], e);
                        EventSystem.triggerEvent("Codestrates.Fragment.Error", {
                            messages: ["Error in lua: ", parsedStack],
                            fragment: self
                        });
                        reject(e);
                        return;
                    }
                }

                //Create a new Lua State
                let L = fengari.lauxlib.luaL_newstate();
                //Load the standardlibs
                fengari.lualib.luaL_openlibs(L);

                //Load javascript lib and pop it again
                fengari.lauxlib.luaL_requiref(L, fengari.to_luastring("js"), fengari.interop.luaopen_js, 1);
                fengari.lua.lua_pop(L, 1);

                //Setup exports variable
                fengari.interop.push(L, exports)
                fengari.lua.lua_setglobal(L, fengari.to_luastring("exports"));

                //Setup access to console
                fengari.interop.push(L, JsEvalEngine.defaultOptions(self).customConsole);
                fengari.lua.lua_setglobal(L, fengari.to_luastring("console"));

                //Setup promise await function
                fengari.lua.lua_pushjsfunction(L, (L)=>{
                    let promise = fengari.lua.lua_touserdata(L, -1).data;

                    promise.then((result) => {
                        fengari.interop.push(L, result);
                        resumeCorutine(L, 1)
                    }).catch((e)=>{
                        fengari.lua.lua_pushnil(L);
                        fengari.lua.lua_pushliteral(L, '' + e);
                        resumeCorutine(L, 2)
                    });
                    fengari.lua.lua_yield(L, 0);
                });
                fengari.lua.lua_setglobal(L, fengari.to_luastring("pwait"));

                //Prepare lua code
                let luaCode = fengari.to_luastring(this.raw);

                //Load lua code
                let retVal = fengari.lauxlib.luaL_loadstring(L, luaCode);

                let res = null;

                if(retVal === fengari.lua.LUA_ERRSYNTAX) {
                    res = new SyntaxError(fengari.lua.lua_tojsstring(L, -1));
                } else {
                    res = new Error(fengari.lua.lua_tojsstring(L, -1));
                }

                if(retVal !== fengari.lua.LUA_OK) {
                    let parsedStack = LuaFragment.parseErrorStack(res, self);
                    EventSystem.triggerEvent("Codestrates.Fragment.Error", {
                        messages: ["Error in lua: ", parsedStack],
                        fragment: self
                    });
                    console.error(res);
                    reject(res);
                    return;
                } else {
                    //Run the code
                    resumeCorutine(L, 0)
                }
            });
        });
    }

    static parseErrorStack(e, fragment) {
        let stackLines = e.stack.split("\n");
        return new StackWalker.StackTrace("", [], stackLines[0]);
    }

    async onFragmentsLoaded() {
        if(this.auto && !Fragment.disableAutorun) {
            await this.require();
        }
    }

    supportsRun() {
        return true;
    }

    supportsAuto() {
        return true;
    }

    static type() {
        return "application/x-lua";
    }
}; window.LuaFragment = LuaFragment;

Fragment.registerFragmentType(LuaFragment);

</script>

            </div>
            <div class="package" id="fragment_whenjs">
                <script id="descriptor-script" type="descriptor">
{
    "description": "When.js Fragment for Codestrates",
    "dependencies": [
        "#fragment_core",
        "#js-eval-engine",
        "/when-js-repos/?raw #when-js-engine"
    ],
    "license": "Apache 2.0",
    "assets": [],
    "version": "1.0"
}

</script>

                <script id="fragment_when-script" type="disabled">
/**
 *  WhenJSFragment
 *  Integration for the legacy when.js programming system into Codestrates
 * 
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *    
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

/* global webstrate, cQuery, Fragment, wpm, JsEvalEngine, WhenEngine */

wpm.onRemoved(()=>{
    Fragment.unRegisterFragmentType(WhenJSFragment);
});

/**
 * A fragment that contains When.js code
 *
 * Supports auto - executes require() on load
 * @extends Fragments.Fragment
 * @hideconstructor
 * @memberof Fragments
 * @private
 */
class WhenJSFragment extends Fragment {
    constructor(html) {
        super(html);

        this.whenInstance = globalWhenEngine.createInstance(this.uuid);
    }

    require(options = {}) {
        //Clear all instance state
        try {
            this.whenInstance.reset();
        } catch(e) {
            console.warn(e);
        }

        //Add fragment self reference to local context
        this.whenInstance.addToLocalContext("fragmentSelfReference", this);

        //Rerun all when.js code
        const code = this.raw;

        const whenContext = {
            define: (newAlias, aliases, parameterMapping=null)=>{
                return this.whenInstance.define(newAlias, aliases, parameterMapping);
            },
            undefine: (alias)=>{
                return this.whenInstance.undefine(alias);
            },
            redefine: (newAlias, aliases, parameterMapping=null)=>{
                return this.whenInstance.redefine(newAlias, aliases, parameterMapping);
            },
            when: (eventName)=>{
                return this.whenInstance.when(eventName);
            },
            registerFilter: (filterName, filter)=>{
                this.whenInstance.registerFilter(filterName, filter);
            },
            unregisterFilter: (filterName)=>{
                this.whenInstance.unregisterFilter(filterName);
            },
            registerGenerator: (generator)=>{
                this.whenInstance.registerGenerator(generator);
            },
            unregisterGenerator: (generator)=>{
                this.whenInstance.unregisterGenerator(generator);
            },
            load: (json)=>{
                this.whenInstance.load(json);
            },
            instance: this.whenInstance,
            engine: globalWhenEngine
        };

        if(options.context != null) {
            options.context = Object.assign(whenContext, options.context);
        } else {
            options.context = whenContext;
        }

        return JsEvalEngine.execute(code, options, this).catch((e)=>{
            console.error("Error during when.js execution:", e);
        });
    }

    async onFragmentsLoaded() {
        if(this.auto && !Fragment.disableAutorun) {
            await this.require();
        }
    }

    unload() {
        //Clear all instance state
        try {
            this.whenInstance.reset();
        } catch(e) {
            console.warn(e);
        }

        super.unload();
    }

    supportsRun() {
        return true;
    }

    supportsAuto() {
        return true;
    }

    static type() {
        return "text/whenjs";
    }
}; window.WhenJSFragment = WhenJSFragment;

Fragment.registerFragmentType(WhenJSFragment).then(()=>{
    EventSystem.triggerEvent("WhenJSFragments.loaded");
});

</script>

            </div>

            <div class="package" id="editor_core">
                <script id="descriptor-script" type="descriptor">
{
    "description": "The base editor core required by all Codestrate editors",
    "dependencies": [
        "/wpm_js_libs/?raw #cQuery",
        "/wpm_js_libs/?raw #CaviTouch",
        "#fragment_core",
        "#EventSystem"
    ],
    "license": "Apache 2.0",
    "assets": [],
    "version": "1"
}

</script>

                <script id="editor_core-script" type="disabled">
/**
 *  Editor and EditorManager
 *  Base classes for handling editors in Codestrates
 * 
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *    
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

/* global cQuery, webstrate */

/**
 * Triggers when a selection changes inside an editor
 * @event Editors.Editor.EventSystem:"Codestrates.Editor.Selection"
 * @type {Event}
 * @property {Editors.Editor} editor - The editor that triggered the event
 * @property {Editors.Editor~cursorSelection} selection - The selection
 */

/**
 * Triggers when an editor looses focus
 * @event Editors.Editor.EventSystem:"Codestrates.Editor.Blur"
 * @type {Event}
 * @property {Editors.Editor} editor - The editor that triggered the event
 */

/**
 * Triggers when an editor gains focus
 * @event Editors.Editor.EventSystem:"Codestrates.Editor.Focus"
 * @type {Event}
 * @property {Editors.Editor} editor - The editor that triggered the event
 */
/**
 * Triggers when an editor is closed
 * @event Editors.Editor.EventSystem:"Codestrates.Editor.Closed"
 * @type {Event}
 * @property {Editors.Editor} editor - The editor that triggered the event
 */
/**
 * Triggers when an editor is opened
 * @event Editors.Editor.EventSystem:"Codestrates.Editor.Opened"
 * @type {Event}
 * @property {Editors.Editor} editor - The editor that triggered the event
 */

/**
 * @namespace Editors
 */

/**
 * EditorManager
 *
 * @memberof Editors
 */
class EditorManager {
    /**
     * @private
     */
    static registerEditor(editor) {
        editor.types().forEach((type)=>{
            let editors = EditorManager.editorTypes.get(type);
            if(editors == null) {
                editors = new Set();
                EditorManager.editorTypes.set(type, editors);
            }

            editors.add(editor);
        });
    }

    /**
     * @private
     */
    static unregisterEditor(editor, editorClassName) {
        editor.types().forEach((type)=>{
            let editors = EditorManager.editorTypes.get(type);
            if(editors == null) {
                editors = new Set();
                EditorManager.editorTypes.set(type, editors);
            }

            editors.delete(editor);
        });
        
        cQuery("."+editorClassName).forEach((editor)=>{
            editor = cQuery(editor).data("Editor");
            if(editor != null) {
                editor.unload();
            }
        });
    }

    /**
     * @typedef {Object} EditorManager~EditorConfig
     * @property {Editors.Editor} [editor] - The editor to use.
     * @property {string} [theme] -  The theme to use, supports "light" or "dark".
     * @property {string} [mode] - The editor mode, supports "inline" or "full".
     * @property {boolean} [readOnly] - Should the editor be read only.
     */

    /**
     * Create an editor for the given fragment/array of fragments.
     *
     * <pre><code>config options:
     *  editor: null | EditorClass -- If not null, tries to create the specified editor
     *  theme: "light" | "dark" -- The theme to use for the editor
     *  mode: "inline" | "full" -- Inline fills the space its in, full resizes the editor to show all lines.
     *  readOnly: true|false -- Should the editor be read only</code></pre>
     *
     * @example
     * let editor = EditorManager.create(Fragment.one("#myFragment"), {theme:"light", mode: "full"})[0];
     *
     * @param {Fragments.Fragment|Fragments.Fragment[]} fragment - The fragment, or array of fragments to create the editors from
     * @param {EditorManager~EditorConfig} config - The editor config to use
     * @returns {Editors.Editor[]} the created editors
     */
    static createEditor(fragment, config = {}) {
        let result = [];
        
        let defaultConfig = {
            editor: null,
            theme: "light",
            mode: "inline",
            readOnly: false
        };
        
        config = Object.assign({}, defaultConfig, config);
        
        if(Array.isArray(fragment)) {
            for(let frag of fragment) {
                result = result.concat(EditorManager.createEditor(frag, config));
            }
        } else {
            if(config.editor != null) {
                if(config.editor.types().includes(fragment.type)) {
                    result.push(new config.editor(fragment, config));
                } else {
                    let newConfig = Object.assign({}, config);
                    newConfig.editor = null;
                    result = result.concat(EditorManager.createEditor(fragment, newConfig));
                    if(result.length === 0) {
                        console.warn(config.editor.name+" does not support fragment type:", fragment.constructor.type());
                        console.warn("Auto editor discovery did not find any usable editors.");
                    } else {
                        console.log(config.editor.name+" does not support fragment type:", fragment.constructor.type());
                        console.log("Auto editor discovery: ", result);
                    }
                }
            } else {
                let editors = EditorManager.editorTypes.get(fragment.type);

                if(editors == null) {
                    editors = new Set();
                    EditorManager.editorTypes.set(fragment.type, editors);
                }

                //Filter preview editor from auto discovery, as it can not edit.
                const availableEditors = Array.from(editors).filter((editor)=>{
                    return editor !== PreviewEditor;
                });

                if(availableEditors.size > 0) {

                    //TODO: Maybee not just use the first editor available?
                    result.push( new (availableEditors[0])(fragment, config));
                }
            }
        }
        
        return result;
    }

    /**
     * Used to load CSS for implementing editors
     * @private
     */
    static loadCss(url) {
        return new Promise((resolve, reject)=>{
            let link = document.createElement("link");
            link.type = "text/css";
            link.rel = "stylesheet";
            link.href = url;

            link.setAttribute("transient-element", "");

            document.head.append(link);

            link.onload = ()=>{
                resolve();
            };
        });
    }
}; window.EditorManager =  EditorManager;

EditorManager.editorTypes = new Map();

/**
 * Editor represents a fragment editor
 * @abstract
 * @memberof Editors
 * @hideconstructor
 */
class Editor {
    constructor(htmlClass, fragment, options = {}) {
        this.html = cQuery("<div class='codestrates-editor-core'></div>");
        this.html.data("Editor", this);
        
        this.fragment = fragment;
        this.handleModelChanges = true;

        this.options = options;

        this.editorDiv = cQuery("<div class='codestrates-editor-core-view "+htmlClass+"'></div>");

        this.html.append(this.editorDiv);

        this.foreignSelections = new Map();

        this.eventDeleters = [];

        if(options.mode === "inline") {
            this.verticalResizeHandle = cQuery("<div class=\"codestrates-editor-core-resizer\"></div>");
            this.html.append(this.verticalResizeHandle);
            this.setupResizer();
            this.html.addClass("resizeable");
        } else if(options.mode === "component") {
            this.html.addClass("component");
        } else if(options.mode === "full") {
            //Do nothing atm.
        }

        let self = this;

        this.eventDeleters.push(this.fragment.registerOnFragmentChangedHandler((context)=>{
            if(context === self) {
                return;
            }
            
            self.handleFragmentChanged();
        }));

        this.eventDeleters.push(this.fragment.registerOnTextInsertedHandler((pos, val)=>{
            self.handleTextInserted(pos, val);
        }));

        this.eventDeleters.push(this.fragment.registerOnTextDeletedHandler((pos, val)=>{
            self.handleTextDeleted(pos, val);
        }));

        this.resizeHandler = function() {
            self.onSizeChanged();
        };

        this.focusOutHandler = function() {
            self.triggerEditorLostFocus();
        };

        this.focusInHandler = function() {
            self.triggerEditorGainedFocus();
        };

        window.addEventListener("resize", this.resizeHandler);

        this.html[0].addEventListener("focusout", this.focusOutHandler);

        this.html[0].addEventListener("focusin", this.focusInHandler);

        //Setup live query to listen for cursors
        this.otherCursorLiveQuery = this.html.liveQuery("[class*='otherCursor_']", {
            added: (obj)=>{
                obj.classList.add("otherCursor");
            }
        });
        this.otherSelectorLiveQuery = this.html.liveQuery("[class*='otherSelector_']", {
            added: (obj)=>{
                obj.classList.add("otherSelector");
            }
        });

        this.waitForDomInsertion().then(()=>{
            self.waitForDisplay().then(()=>{
                self.onSizeChanged();
            });
        });
    }

    waitForDisplay() {
        let self = this;

        return new Promise((resolve, reject)=>{
            function checkDisplay() {
                try {
                    if (self.html[0].offsetWidth > 0) {
                        resolve();
                    } else {
                        setTimeout(checkDisplay, 100);
                    }
                } catch(e) {

                }
            }

            checkDisplay();
        });
    }

    waitForDomInsertion() {
        let self = this;

        return new Promise((resolve, reject)=>{
            let observer = new MutationObserver((mutations)=>{
                let foundEditor = false;
                mutations.forEach((mutation)=>{
                    Array.from(mutation.addedNodes).forEach((addedNode)=>{
                        if(addedNode === self.html[0]) {
                            foundEditor = true;
                        } else {
                            let parent = self.html[0].parentNode;

                            while(parent != null) {
                                if(parent === addedNode) {
                                    foundEditor = true;
                                    break;
                                }

                                parent = parent.parentNode;
                            }
                        }
                    });
                });

                if(foundEditor) {
                    observer.disconnect();
                    resolve();
                }
            });

            observer.observe(document, {
                childList: true,
                subtree: true
            });
        });
    }

    /**
     * Focuses the editor
     */
    focus() {
        //Override in subclass
    }

    /**
     * Sets the currently active line
     */
    setLine(line, column=1) {
        //Override in subclass
    }


    /**
     * @typedef {object} Editors.Editor~cursorSelection
     * @property {number} startLine
     * @property {number} startColumn
     * @property {number} endLine
     * @property {number} endColumn
     * @property {number} positionLine
     * @property {number} positionColumn
     */

    /**
     * Sets a forign client selection marker in this editor
     * @param {String} remoteClient - Webstrate clientId of the remote client that has a selection in the fragment this editor is editing
     * @param {Editors.Editor~cursorSelection} cursorSelection - The selection
     */
    setForeignSelection(remoteClient, cursorSelection) {
        if(cursorSelection == null) {
            this.foreignSelections.delete(remoteClient);
        } else {
            this.foreignSelections.set(remoteClient, cursorSelection);
        }
        this.updateForeignSelections(remoteClient);
    }

    /**
     * @private
     */
    updateForeignSelections(remoteClient=null) {
        //Overrite in subclass
    }

    /**
     * @private
     */
    triggerCursorSelection(selection) {
        EventSystem.triggerEvent("Codestrates.Editor.Selection", {
            editor: this,
            selection: selection
        });
    }

    /**
     * @private
     */
    triggerEditorLostFocus() {
        EventSystem.triggerEvent("Codestrates.Editor.Blur", {
            editor: this
        });
    }

    /**
     * @private
     */
    triggerEditorGainedFocus() {
        EventSystem.triggerEvent("Codestrates.Editor.Focus", {
            editor: this
        });
    }

    /**
     * @private
     */
    triggerEditorClosed() {
        EventSystem.triggerEvent("Codestrates.Editor.Closed", {
            editor: this
        });
    }

    /**
     * @private
     */
    triggerEditorOpened() {
        EventSystem.triggerEvent("Codestrates.Editor.Opened", {
            editor: this
        });
    }

    /**
     * @private
     */
    onSizeChanged() {
        //Overwrite in subclass
    }

    /**
     * @private
     */
    setupResizer() {
        let self = this;
        
        new CaviTouch(this.verticalResizeHandle, {
            dragMinDistance: 0
        });
        
        this.verticalResizeHandle.on("caviDrag", (evt)=>{
            let height = self.html[0].clientHeight + evt.detail.caviEvent.deltaPosition.y;
            self.html[0].style.height = height+"px";
            self.onSizeChanged();
        });
    }

    /**
     * @private
     */
    handleFragmentChanged() {
        let self = this;

        this.handleModelChanges = false;
        try {
            let editorValue = this.getValue();
            let fragmentValue = this.fragment.raw;

            if(editorValue !== fragmentValue) {
                this.setValue(this.fragment.raw);
            }
        } catch(e) {
            console.error("Error setting fragment value:", e);
        }
        
        setTimeout(()=>{
            self.handleModelChanges = true;
        },0);
    }

    /**
     * @private
     */
    handleTextInserted(pos, val) {
        let self = this;

        this.handleModelChanges = false;
        try {
            this.insertText(pos, val);
        } catch(e) {
            console.error("Error setting fragment value:", e);
        }
        
        setTimeout(()=>{
            self.handleModelChanges = true;
        },0);
    }

    /**
     * @private
     */
    handleTextDeleted(pos, val) {
        let self = this;

        this.handleModelChanges = false;
        try {
            this.deleteText(pos, val);
        } catch(e) {
            console.error("Error setting fragment value:", e);
        }
        
        setTimeout(()=>{
            self.handleModelChanges = true;
        },0);
    }

    /**
     * @private
     */
    handleModelChanged() {
        let self = this;
        
        if(this.handleModelChanges) {
            let changedValue = this.getValue();

            if(changedValue !== self.fragment.raw) {
                this.fragment.executeObserverless(() => {
                    EventSystem.triggerEvent("Codestrates.Editor.BeforeModelChanged", {
                        editor: this
                    });
                    self.fragment.raw = changedValue;
                    EventSystem.triggerEvent("Codestrates.Editor.AfterModelChanged", {
                        editor: this
                    });
                }, this);
            }
        }
    }

    /**
     * Get the current string value of this editor
     * @returns {string}
     */
    getValue() {
        //Override in subclass
        console.warn("getValue not overridden", this);
    }

    /**
     * Sets the current string value of this editor
     * @param {string} value
     */
    setValue(value) {
        //Override in subclass
        console.warn("setValue not overridden", this);
    }

    /**
     * Inserts text into this editor
     * @param {number} pos - The position to insert at
     * @param {string} val - The value to insert
     */
    insertText(pos, val) {
        //Override in subclass
        console.warn("insertText not overridden", this);
    }

    /**
     * Inserts text into this editor
     * @param {number} pos - The position to delete from
     * @param {string} val - The value to delete
     */
    deleteText(pos, val) {
        //Override in subclass
        console.warn("deleteText not overridden", this);
    }

    /**
     * Inserts the given text at the current selection, if no selection just insert at the cursor position, else replace the current selection.
     * @param {string} text - The text to insert
     */
    insertAtSelection(text) {
        //Override in subclass
        console.warn("insertAtSelection not overridden", this, text);
    }

    /**
     * Unloads this editor
     */
    unload() {
        this.triggerEditorClosed();

        this.eventDeleters.forEach((deleter)=>{
            deleter.delete();
        });

        window.removeEventListener("resize", this.resizeHandler);

        this.html[0].removeEventListener("focusout", this.focusOutHandler);

        this.html[0].removeEventListener("focusin", this.focusInHandler);

        this.otherCursorLiveQuery.stop();
        this.otherSelectorLiveQuery.stop();
        this.html.remove();
        this.html.data("Editor", null);
        this.html = null;
    }
}; window.Editor = Editor;

</script>

                <style id="base-style">
/**
 *  Editor styles
 *  Base classes for handling editors in Codestrates
 * 
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *    
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

.codestrates-editor-core {
    position: relative;
}

.codestrates-editor-core.unsaved {
    border: crimson solid 2px;
}

.codestrates-editor-core-view {
    height: 100%;
}

.codestrates-editor-core.component {
    height: 100%;
}

.codestrates-editor-core.resizeable {
    min-height: 6em;
    height: 6em;
}
.codestrates-editor-core.resizeable .codestrates-editor-core-resizer {
    position: absolute;
    cursor: ns-resize;
    left: 0;
    top: 100%;
    width: 100%;
    opacity: 0.2;
    height: 0.5em;
    border-top: 0.2em solid rgba(0,0,0,0.5);
    transition: opacity 0.20s ease-out, border-top-width 0.20s ease-out;
    z-index: 4;
}
.codestrates-editor-core.resizeable .codestrates-editor-core-resizer:hover {
    opacity: 1;
    border-top-width: 0.75em;
}
</style>

            </div>
            <div class="package" id="editor_monaco">
                <script id="descriptor-script" type="descriptor">
{
    "description": "Plugin to use Monaco Editor",
    "dependencies": [
        "/wpm_js_libs/?raw #monaco_editor",
        "#editor_core"
    ],
    "license": "Apache 2.0 (w/MIT)",
    "assets": [],
    "version": "1"
}

</script>

                <script id="editor_monaco-script" type="disabled">
/**
 *  MonacoEditor
 *  Wrapper for using the Monaco editor in Codestrates
 * 
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *    
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

/* global webstrate, cQuery, Editor, monaco, EditorManager */

wpm.onRemoved(()=>{
    EditorManager.unregisterEditor(MonacoEditor, "monaco-editor");
});

/**
 * An editor implementation using Monaco
 *
 * @memberof Editors
 * @extends Editors.Editor
 */
class MonacoEditor extends Editor {
    constructor(fragment, options = {}) {
        super("monaco-editor", fragment, options);

        this.options = options;

        this.foreignDecorators = new Map();

        this.setupEditor();
    }

    async setupEditor() {
        let self = this;

        let language = "text";

        switch (self.fragment.type) {
            case "text/x-latex":
                language = "plaintext";
                break;

            case "text/javascript":
                language = "javascript";
                break;

            case "text/javascript":
                language = "javascript";
                break;

            case "text/p5js":
                language = "javascript";
                break;

            case "text/whenjs":
                language = "javascript";
                break;

            case "text/python":
                language = "python";
                break;
                
            case "text/markdown":
                language = "markdown";
                break;

            case "text/html":
                language = "html";
                break;

            case "text/css":
                language = "css";
                break;

            case "text/x-scss":
                language = "scss";
                break;
                
            case "application/x-lua":
                language = "lua";
                break;                

            case "text/ruby":
                language = "ruby";
                break;

            case "text/x-typescript":
                language = "typescript";
                break;

            case "wpm/descriptor":
            case "application/json":
            case "text/whenv2":
                language = "json";
                break;
        }

        requirejs(["vs/editor/editor.main"], () => {
            EventSystem.triggerEvent("Codestrates.Editor.Monaco.Loaded", {
                monaco: monaco
            });

            let theme = "vs";

            if (self.options.theme === "dark") {
                theme = "vs-dark";
            }

            monaco.languages.json.jsonDefaults.diagnosticsOptions.enableSchemaRequest = true;

            self.editor = monaco.editor.create(self.editorDiv[0], {
                value: this.fragment.raw,
                language: language,
                theme: theme,
                minimap: {
                    enabled: false
                },
                automaticLayout: false,
                fixedOverflowWidgets: true,
                contextmenu: false,
                scrollBeyondLastLine: false,
                scrollBeyondLastColumn: 0,
                occurrencesHighlight: false,
                selectionHighlight: false,
                accessibilitySupport: "off",
                folding: false,
                renderIndentGuides: false,
                readOnly: this.options.readOnly,
                scrollbar: {
                    alwaysConsumeMouseWheel: false,
                    horizontal: 'auto',
                    vertical: 'auto',
                    horizontalScrollbarSize: 17
                }
            });

            self.editor.getModel().setEOL(0);

            if (self.options.mode === "full") {
                //Setup resizeing for all the lines

                self.editor.getModel().onDidChangeContent(()=>{self.updateSize();});
                self.editor.getModel().onDidChangeDecorations(()=>{
                    setTimeout(()=>{
                        self.updateSize();
                    }, 0);
                });

                self.updateSize();
            }

            self.editor.getModel().onDidChangeContent((evt) => {
                self.handleModelChanged();
            });

            self.editor.onDidChangeCursorSelection((evt)=>{
                self.triggerCursorSelection({
                    startLine: evt.selection.startLineNumber,
                    startColumn: evt.selection.startColumn,
                    endLine: evt.selection.endLineNumber,
                    endColumn: evt.selection.endColumn,
                    positionLine: evt.selection.positionLineNumber,
                    positionColumn: evt.selection.positionColumn
                });
            });

            self.triggerEditorOpened();
        });
    }

    focus() {
        let self = this;

        if(this.editor == null) {
            //Try to focus the editor as soon as its created.
            setTimeout(()=>{
                self.focus();
            }, 100);
        } else {
            this.editor.focus();
        }
    }

    setLine(line, column=1) {
        let self = this;

        if(this.editor == null) {
            //Try to focus the editor as soon as its created.
            setTimeout(()=>{
                self.setLine(line);
            }, 100);
        } else {
            this.editor.revealLineNearTop(line);
            this.editor.setPosition({
                column: column,
                lineNumber: line
            });
        }
    }   

    updateSize() {
        let oldWidth = this.editor.getLayoutInfo().width;
        let numLines = this.editor._modelData.viewModel._lines.getViewLineCount();

        let height = 19;

        let viewLines = this.editorDiv.find("div.view-line");

        if (viewLines.length > 0) {
            height = viewLines[0].offsetHeight;
        }

        this.editor.layout({
            width: oldWidth,
            height: numLines * height
        });

        let scrollHeight = this.editor.getScrollHeight();

        if(this.editor.getLayoutInfo().height !== scrollHeight) {
            this.editor.layout({
                width: oldWidth,
                height: scrollHeight
            });
        }
    }

    onSizeChanged() {
        if (typeof this.editor!=="undefined"){

            this.editor.layout();

            if(this.mode === "full") {
                this.updateSize();
            }
        }
    }

    updateForeignSelections(remoteClient = null) {
        let self = this;

        if(this.editor == null) {
            //Editor not ready yet.
            return;
        }

        let clientsToUpdate = [];

        if(remoteClient != null) {
            clientsToUpdate.push(remoteClient);
        } else {
            clientsToUpdate = Array.from(this.foreignSelections.keys());
        }

        clientsToUpdate.forEach((client)=>{
            let cursorSelection = self.foreignSelections.get(client);
            let decorations = self.foreignDecorators.get(client);

            if(decorations == null) {
                decorations = [];
            }

            let updatedDecoration = [];

            if(cursorSelection != null) {
                updatedDecoration.push({
                    range: new monaco.Range(cursorSelection.positionLine, cursorSelection.positionColumn, cursorSelection.positionLine, cursorSelection.positionColumn),
                    options: {
                        className: "otherCursor_" + client,
                        zIndex: 1
                    }
                });

                if (cursorSelection.startLine != cursorSelection.endLine || cursorSelection.startColumn != cursorSelection.endColumn) {
                    updatedDecoration.push({
                        range: new monaco.Range(cursorSelection.startLine, cursorSelection.startColumn, cursorSelection.endLine, cursorSelection.endColumn),
                        options: {
                            className: "otherSelection_" + client,
                            zIndex: 0
                        }
                    });
                }
            }

            decorations = self.editor.deltaDecorations(decorations, updatedDecoration);

            self.foreignDecorators.set(client, decorations);
        });
    }

    getValue() {
        if(this.editor == null) {
            return null;
        }
        
        return this.editor.getModel().getValue();
    }

    setValue(value) {
        if(this.editor == null) {
            return;
        }
        
        this.editor.getModel().setValue(value);
    }

    insertText(pos, val) {
        if(this.editor == null) {
            return;
        }
        
        let startPosition = this.editor.getModel().getPositionAt(pos);
        let range = monaco.Range.fromPositions(startPosition, startPosition);
        
        this.editor.getModel().applyEdits([{
            forceMoveMarkers: true,
            range: range,
            text: val
        }]);

        this.updateForeignSelections();
    }
    
    deleteText(pos, val) {
        if(this.editor == null) {
            return;
        }
        
        let startPosition = this.editor.getModel().getPositionAt(pos);
        let endPosition = this.editor.getModel().getPositionAt(pos+val.length);
        let range = monaco.Range.fromPositions(startPosition, endPosition);
        
        this.editor.getModel().applyEdits([{
            range: range,
            text: ""
        }]);

        this.updateForeignSelections();
    }

    insertAtSelection(text) {
        this.editor.executeEdits("draggedIntoEditor", [{
            identifier: {
                major: 1,
                minor: 1
            },
            range: this.editor.getSelection(),
            text: text,
            forceMoveMarkers: true
        }]);
    }

    unload() {
        //Kill monaco?
        if(this.editor != null) {
            this.editor.getModel().dispose();
            this.editor.dispose();
            this.editor = null;
        }

        super.unload();
    }

    static types() {
        return [
            "text/javascript",
            "text/p5js",
            "text/whenjs",
            "text/whenv2",
            "text/varv",
            "text/python",
            "text/markdown",
            "text/html",
            "text/css",
            "text/ruby",
            "text/x-scss",
            "text/x-typescript",
            "application/x-lua",
            "wpm/descriptor",
            "application/json",
            "text/x-latex"
        ];
    }
}; window.MonacoEditor = MonacoEditor;

EditorManager.registerEditor(MonacoEditor);

</script>

                <style id="base-style">
.decorationsOverviewRuler {
    display: none;
}

.otherCursor::before {
    content: " ";
    width: 2px;
    height: 100%;
    display: block;
}

.otherSelection {
}
</style>

            </div>
            <div class="package" id="editor_codemirror">
                <script id="descriptor-script" type="descriptor">
{
    "description": "Plugin to use Codemirror Editor",
    "dependencies": [
        "/wpm_js_libs/?raw #codemirror_editor",
        "#editor_core"
    ],
    "license": "Apache 2.0 (w/MIT)",
    "assets": [],
    "version": "1"
}

</script>

                <script id="editor_codemirror-script" type="disabled">
/**
 *  CodemirrorEditor
 *  Wrapper for using the CodeMirror editor in Codestrates
 * 
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *    
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

/* global webstrate, cQuery, Editor, monaco, EditorManager */

wpm.onRemoved(()=>{
    EditorManager.unregisterEditor(CodemirrorEditor, "codemirror-editor");
});

/**
 * An editor implementation using CodeMirror
 *
 * @memberof Editors
 * @extends Editors.Editor
 */
class CodemirrorEditor extends Editor {
    constructor(fragment, options = {}) {
        super("codemirror-editor", fragment, options);
        
        this.setupEditor();
    }
    
    setupEditor() {
        let self = this;
        
        let mode = "text";
        let module = "text";
        let addons = [];
        let styles = [];

        let p5Theme = false;

        switch(self.fragment.type) {
            case "text/p5js":
                mode = "javascript";
                module = "p5-javascript";
                p5Theme = true;
                break;

            case "text/ruby":
                mode = "text/x-ruby";
                module = "ruby";
                break;

            case "text/python":
                mode = "python";
                module = "python";
                break;

            case "text/markdown":
                mode = "markdown";
                module = "markdown";
                break;

            case "text/x-typescript":
                mode = "text/typescript";
                module = "javascript";
                addons.push("cm/addon/hint/show-hint", "cm/addon/hint/javascript-hint");
                styles.push(CodemirrorLibraryPath+"/addon/hint/show-hint.css");
                break;

            case "text/javascript":
                mode = "javascript";
                module = "javascript";
                addons.push("cm/addon/hint/show-hint", "cm/addon/hint/javascript-hint");
                styles.push(CodemirrorLibraryPath+"/addon/hint/show-hint.css");
                break;

            case "text/x-scss":
                mode = "text/x-scss";
                module = "css";
                break;

            case "text/html":
                mode = "htmlmixed";
                module = "htmlmixed";
                addons.push("cm/addon/hint/show-hint", "cm/addon/hint/html-hint");
                styles.push(CodemirrorLibraryPath+"/addon/hint/show-hint.css");
                break;
                
            case "text/css":
                mode = "css";
                module = "css";
                addons.push("cm/addon/hint/show-hint", "cm/addon/hint/css-hint");
                styles.push(CodemirrorLibraryPath+"/addon/hint/show-hint.css");
                break;
                
            case "text/x-latex":
                mode = "stex";
                module = "stex";
                break;                

            case "wpm/descriptor":
            case "application/json":
                module = "javascript";
                mode = {
                    name: "javascript",
                    json: true
                };
                break;
        }

        let requireModules = ["cm/lib/codemirror", "cm/mode/"+module+"/"+module];

        requireModules.push(...addons);

        requirejs(requireModules, (CodeMirror)=>{
            let theme = "default";

            let stylePromises = [];

            styles.forEach((style)=>{
                stylePromises.push(EditorManager.loadCss(style));
            });

            Promise.all(stylePromises).then(()=>{
                EditorManager.loadCss(CodemirrorLibraryPath+"/lib/codemirror.css").then(()=>{
                    switch(self.options.theme) {
                        case "light":
                            if(p5Theme) {
                                theme = "p5-light";
                                EditorManager.loadCss(CodemirrorLibraryPath+"/theme/p5-light.css").then(()=>{
                                    self.onSizeChanged();
                                });
                            } else {
                                theme = "default";
                            }
                            break;
                        case "dark":
                            if(p5Theme) {
                                theme = "p5-dark";
                                EditorManager.loadCss(CodemirrorLibraryPath+"/theme/p5-dark.css").then(()=>{
                                    self.onSizeChanged();
                                });
                            } else {
                                theme = "darcula";
                                EditorManager.loadCss(CodemirrorLibraryPath+"/theme/darcula.css").then(()=>{
                                    self.onSizeChanged();
                                });
                            }
                            break;
                    }

                    self.editor = CodeMirror(self.editorDiv[0], {
                        value: self.fragment.raw,
                        mode: mode,
                        extraKeys: {"Ctrl-Space": "autocomplete"},
                        lineNumbers: true,
                        theme: theme,
                        hintOptions: {
                            container: self.html[0]
                        }
                    });

                    self.editor.on("changes", ()=>{
                        self.handleModelChanged();
                    });

                    self.onSizeChanged();
                });
            });
        });
    }
    
    onSizeChanged() {
        if(this.editor != null) {
            if(self.mode === "component") {
                this.editor.setSize("100%", "100%");
            } else {
                this.editor.setSize(null, null);
            }
            this.editor.refresh();
        }
    }
    
    getValue() {
        if(this.editor != null) {
            return this.editor.getDoc().getValue();
        }
    }
    
    setValue(value) {
        if(this.editor != null) {
            this.editor.getDoc().setValue(value);
        }
    }

    insertText(pos, val) {
        if(this.editor == null) {
            return;
        }
        
        let startPosition = this.editor.getDoc().posFromIndex(pos);
        
        this.editor.getDoc().replaceRange(val, startPosition);
    }
    
    deleteText(pos, val) {
        if(this.editor == null) {
            return;
        }
        
        let startPosition = this.editor.getDoc().posFromIndex(pos);
        let endPosition = this.editor.getDoc().posFromIndex(pos+val.length);
        
        this.editor.getDoc().replaceRange("", startPosition, endPosition);
    }

    static types() {
        return [
            "text/python",
            "text/javascript",
            "text/html",
            "text/css",
            "text/markdown",
            "text/ruby",
            "text/x-scss",
            "wpm/descriptor",
            "application/json",
            "text/x-typescript",
            "text/x-latex",
            "text/p5js"
        ];
    }
}; window.CodemirrorEditor = CodemirrorEditor;

EditorManager.registerEditor(CodemirrorEditor);

</script>

                <style id="base-style">
.codemirror-editor .CodeMirror {
  height: 100%; }
</style>

            </div>
            <div class="package" id="editor_ace">
                <script id="descriptor-script" type="descriptor">
{
    "description": "Plugin to use Ace Editor",
    "dependencies": [
        "/wpm_js_libs/?raw #ace_editor",
        "#editor_core"
    ],
    "license": "Apache 2.0 (w/BSD)",
    "assets": [],
    "version": "1"
}

</script>

                <script id="editor_ace-script" type="disabled">
/**
 *  JsEvalEngine
 *  Evaluate js while keeping track of it
 * 
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *    
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

/* global webstrate, cQuery, Editor, monaco, EditorManager, ace */

wpm.onRemoved(()=>{
    EditorManager.unregisterEditor(AceEditor, "ace-editor");
});

/**
 * An editor implementation using Ace
 *
 * @memberof Editors
 * @extends Editors.Editor
 */
class AceEditor extends Editor {
    constructor(fragment, options = {}) {
        super("ace-editor", fragment, options);
        
        this.setupEditor();
    }
    
    setupEditor() {
        let self = this;
        
        let mode = "text";

        switch(self.fragment.type) {
            case "text/javascript":
                mode = "javascript";
                break;

            case "text/css":
                mode = "css";
                break;

            case "image/svg+xml":
                mode = "svg";
                break;

            case "text/html":
                mode = "html";
                break;
                
            case "text/x-scss":
                mode = "scss";
                break;
                
            case "wpm/descriptor":
            case "application/json":
                mode = "json";
                break;
        }

        requirejs(["ace/ace"], (ace)=>{
            ace.config.set("packaged", true);
            ace.config.set("basePath", require.toUrl("ace"));
            
            self.editor = ace.edit(self.editorDiv[0]);
            self.editor.setValue(self.fragment.raw, 1);
            self.editor.session.setMode("ace/mode/"+mode);

            if(self.options.theme === "dark") {
                self.editor.setTheme("ace/theme/merbivore");
            }

            if(self.options.mode === "full") {
                self.editor.setAutoScrollEditorIntoView(true);
                self.editor.setOption("maxLines", 999999);
            }

            if(self.options.mode === "component") {
                self.editorDiv[0].style.height = "100%";
                self.editorDiv[0].style.width = "100%";
            }

            self.editor.session.on("change", ()=>{
                self.handleModelChanged();
            });
        });
    }

    onSizeChanged() {
        if (this.editor != null) {
            this.editor.resize();
        }
    }

    getValue() {
        if(this.editor == null) {
            return null;
        }
        
        return this.editor.getValue();
    }
    
    setValue(value) {
        if(this.editor == null) {
            return;
        }
        
        this.editor.setValue(value, this.editor.getCursorPosition());
    }
    
    insertText(pos, val) {
        if(this.editor == null) {
            return;
        }
        
        let startPosition = this.editor.session.getDocument().indexToPosition(pos);
        
        this.editor.session.getDocument().insert(startPosition, val);
    }
    
    deleteText(pos, val) {
        if(this.editor == null) {
            return;
        }
        
        let startPosition = this.editor.session.getDocument().indexToPosition(pos);
        let endPosition = this.editor.session.getDocument().indexToPosition(pos + val.length);
        
        let range = new ace.Range(startPosition.row, startPosition.column, endPosition.row, endPosition.column);
        
        this.editor.session.getDocument().remove(range);
    }
    
    static types() {
        return [
            "text/javascript",
            "text/html",
            "text/css",
            "text/x-scss",
            "wpm/descriptor",
            "application/json",
            "image/svg+xml"
        ];
    }
}; window.AceEditor = AceEditor;

EditorManager.registerEditor(AceEditor);

</script>

                <style id="base-style">
.ace-editor {
  height: 100px; }
</style>

            </div>
            <div class="package" id="editor_preview">
                <script id="descriptor-script" type="descriptor">
{
    "description": "Generates previews based on Fragment autoDOM",
    "dependencies": [
        "#editor_core"
    ],
    "license": "Apache 2.0",
    "assets": [],
    "version": "1"
}

</script>

                <script id="editor_preview-script" type="disabled">
/**
 *  PreviewEditor
 *  An "editor" that provides a preview of the autoDOM from a fragment
 * 
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *    
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

/* global webstrate, cQuery, Editor, EditorManager */

wpm.onRemoved(()=>{
    EditorManager.unregisterEditor(PreviewEditor, "preview-editor");
});

/**
 * An editor that renders a preview of the edited fragment
 *
 * @memberof Editors
 * @extends Editors.Editor
 */
class PreviewEditor extends Editor {
    constructor(fragment, options = {}) {
        super("preview-editor", fragment, options);

        this.options = options;

        this.setupEditor();
    }

    setupEditor() {
        let self = this;

        this.fragment.registerOnFragmentChangedHandler(()=>{
            self.updatePreview();
        });

        this.updatePreview();
    }

    async updatePreview() {
        try {
            let fragmentContent = await this.fragment.createAutoDom();

            this.editorDiv.empty();
            if (fragmentContent != null && fragmentContent !== "") {
                this.editorDiv.append(fragmentContent);
            }
        } catch(e) {
            console.warn("Unable to update preview: ", e);
        }
    }
    
    onSizeChanged() {
        //Empty
    }

    getValue() {
        //Empty
    }

    setValue(value) {
        //Empty
    }

    insertText(pos, val) {
        //Empty
    }
    
    deleteText(pos, val) {
        //Empty
    }

    static types() {
        return [
            "text/html",
            "image/svg+xml",
            "text/markdown",
            "text/x-latex"
        ];
    }
}; window.PreviewEditor = PreviewEditor;

EditorManager.registerEditor(PreviewEditor);

</script>

                <style id="main-style">
.codestrates-editor-core .codestrates-editor-core-view.preview-editor {
    background: white;
    contain: paint;
}
</style>

            </div>

            <div class="package" id="plugin_codestrates_namespace">
                <script id="descriptor-script" type="descriptor">
{
    "description": "Places some codestrates functionallity into Codestrates namespace, for easy access",
    "dependencies": [
        "#editor_core",
        "#fragment_core"
    ],
    "license": "Apache 2.0",
    "assets": [],
    "version": "1"
}

</script>

                <script id="codestrates_namespace-script" type="disabled">
/**
 *  Codestrates Namespace
 *  Easy and early access to the Codestrates namespace
 * 
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *    
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

/* global webstrate */

let fragmentExport = {
    create: Fragment.create,
    find: Fragment.find,
    one: Fragment.one
};

let editorManagerExport = {
    create: EditorManager.createEditor
};

let codestrates = {
    fragment: fragmentExport,
    editor: editorManagerExport
};

window.codestrates = codestrates;

</script>

            </div>
            <div class="package" id="EventSystem">
                <script id="descriptor-script" type="descriptor">
{
    "friendlyName": "EventSystem",
    "description": "Can register and fire events",
    "dependencies": [],
    "assets": [],
    "version": "0.1",
    "license": "Apache 2.0",
    "changelog": {
        "0.1": "Initial version"
    }
}

</script>

                <script id="eventsystem-script" type="disabled">
/**
 *  EventSystem
 *  General system for registering and handling events
 * 
 *  Copyright 2020, 2021 Rolf Bagge, Janus B. Kristensen, CAVI,
 *  Center for Advanced Visualization and Interaction, Aarhus University
 *    
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
**/

/**
 * Handles sending / recieving named events
 * @hideconstructor
 */
class EventSystem {
    /**
     * Register a callback to be called when the given event is triggered
     *
     * @example
     * registerEventCallback("myEvent", ({detail: detail})=>{
     *     //My event has triggered
     *     console.log("MyEvent triggered with details:", detail);
     * });
     *
     * @param {string} eventName - The name of the event to register
     * @param {Function} callback - The callback to call when the event triggers
     *
     * @returns {object} - An object with a method delete(), that removes the registered callback
     */
    static registerEventCallback(eventName, callback) {
        let callbacks = EventSystem.callbackMap.get(eventName);
        if(callbacks == null){
            callbacks = new Set();
            EventSystem.callbackMap.set(eventName, callbacks);
        }

        callbacks.add(callback);

        return {
            delete: () => {
                callbacks.delete(callback);
            }
        };
    }

    /**
     * Trigger the event with the given name
     *
     * @example
     * triggerEvent("myEvent", {
     *     someData: "MyEventData"
     * });
     *
     * @param {string} eventName - The name of the event to trigger
     * @param {*} [detail] - The event detail to supply to the CustomEvent
     * @returns {boolean} - true/false depending on if any callback asked to prevent default
     */
    static triggerEvent(eventName, detail = null){
        let event = new CustomEvent(eventName, {
            detail: detail
        });

        let preventDefault = false;

        let callbacks = EventSystem.callbackMap.get(eventName);
        if(callbacks != null) {
            for(let callback of callbacks) {
                if(callback(event) === true) {
                    preventDefault = true;
                }
            }
        }

        return preventDefault;
    }

    /**
     * Trigger the event with the given name
     *
     * @example
     * triggerEvent("myEvent", {
     *     someData: "MyEventData"
     * });
     *
     * @param {string} eventName - The name of the event to trigger
     * @param {*} [detail] - The event detail to supply to the CustomEvent
     * @returns {Promise<boolean>} - true/false depending on if any callback asked to prevent default
     */
    static async triggerEventAsync(eventName, detail = null){
        let event = new CustomEvent(eventName, {
            detail: detail
        });

        let preventDefault = false;

        let callbacks = EventSystem.callbackMap.get(eventName);
        if(callbacks != null) {
            for(let callback of callbacks) {
                if(await callback(event) === true) {
                    preventDefault = true;
                }
            }
        }

        return preventDefault;
    }}

EventSystem.callbackMap = new Map();

window.EventSystem = EventSystem;

</script>

            </div>
        </div>
    </body>
</html>

